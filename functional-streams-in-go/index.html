<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />

        <!-- Enable responsiveness on mobile devices-->
        <!-- viewport-fit=cover is to support iPhone X rounded corners and notch in landscape-->
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover"
        />

        <title>Implementing functional streams with generics in Go | Francisco Souza</title>

        <!-- CSS -->
        <link rel="stylesheet" href="https://blog.fsouza.dev/print.css" media="print"> <link rel="stylesheet" href="https://blog.fsouza.dev/poole.css"> <link
        rel="stylesheet" href="https://blog.fsouza.dev/hyde.css">
        <link
            rel="stylesheet"
            href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"
        />

         <link rel="alternate" type="application/atom+xml" title="RSS" href="https://blog.fsouza.dev/atom.xml">  

<!-- prettier ignore -->
<link rel="stylesheet" href="https://blog.fsouza.dev/custom-style.css?h=4061651ab4fa87df8bc6" />

<!-- prettier ignore -->

    </head>

    <body
        class=" layout-reverse"
    >
        
        <div class="sidebar">
            <div
                class="container sidebar-sticky"
            >
                <div class="sidebar-about">
                    
                    <a href="https:&#x2F;&#x2F;blog.fsouza.dev"
                        ><h1>Francisco Souza</h1></a
                    >
                     
                </div>

                <ul class="sidebar-nav">
                     
                    <li class="sidebar-nav-item">
                        <a href="https:&#x2F;&#x2F;github.com&#x2F;fsouza" rel="me">GitHub</a>
                    </li>
                    
                    <li class="sidebar-nav-item">
                        <a href="https:&#x2F;&#x2F;twitter.com&#x2F;franciscosouza" rel="me">Twitter</a>
                    </li>
                    
                    <li class="sidebar-nav-item">
                        <a href="https:&#x2F;&#x2F;fosstodon.org&#x2F;@fsouza" rel="me">Mastodon</a>
                    </li>
                     
                </ul>
            </div>
        </div>
        

        <div class="content container">
            

<div class="post">
    <h1 class="post-title">Implementing functional streams with generics in Go</h1>
    <span class="post-date">February 12, 2022</span>
    <ul class="tags">
        
        <!-- prettier ignore -->
        <li>
            <a href="https://blog.fsouza.dev/tags/golang/"
                >#golang</a
            >
        </li>
        
        <!-- prettier ignore -->
        <li>
            <a href="https://blog.fsouza.dev/tags/go/"
                >#go</a
            >
        </li>
        
        <!-- prettier ignore -->
        <li>
            <a href="https://blog.fsouza.dev/tags/generics/"
                >#generics</a
            >
        </li>
        
    </ul>
    <!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#the-basic-type-definition">The basic type definition</a></li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#creating-streams">Creating streams</a>
<ul>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#infinite-streams">Infinite streams</a></li>
</ul>
</li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#manipulating-streams">Manipulating streams</a></li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#higher-order-functions">Higher-order functions</a>
<ul>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#map">Map</a></li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#filter">Filter</a></li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#fold">Fold</a></li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#flatmap">FlatMap</a></li>
</ul>
</li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#slicing-streams">Slicing streams</a></li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#putting-it-all-together-in-a-realistic-example">Putting it all together in a realistic example</a>
<ul>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#another-more-interesting-example">Another more interesting example</a></li>
</ul>
</li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#why-not-methods">Why not methods?</a></li>
<li><a href="https://blog.fsouza.dev/functional-streams-in-go/#feedback">Feedback</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<blockquote>
<p><strong>Note 1:</strong> this is an experiment with an upcoming change in Go's type system.
If you need something like what's described in the post in the real world,
use channels, or something like RxGo.</p>
<p><strong>Note 2:</strong> I originally started this post in August and almost abandoned it,
but figured it's still a useful exploration of an important upcoming feature
use channels, or something like RxGo.</p>
</blockquote>
<p>Go 1.18 will support generics, and I decided I would give it a shot. I've been
playing with the idea of <a rel="noopener" target="_blank" href="https://github.com/fsouza/channels">representing streams with
channels</a> and higher order functions that
operate on those channels, allowing processes to execute on streams of data
somewhat-lazily. This is 100% a toy project and a production-ready version of
&quot;lazy/generic streams&quot; will likely come in some future release of
<a rel="noopener" target="_blank" href="https://github.com/ReactiveX/RxGo">RxGo</a>.</p>
<p>Still, while working on a solution to get this working with channels, I figured
we could also try to get it working in a more traditional representation, at
least in functional languages: streams can be represented by a pair - a value
and a function to generate the next value.</p>
<p>I started with a question: with generics, is the Go type-system expressive
enough to represent such streams. And how bad would it look without Ocaml's or
Haskell's type inference capabilities? Turns out we <em>can</em> represent streams,
and the limited type-inference makes it a bit annoying, but it isn't too bad!</p>
<h2 id="the-basic-type-definition">The basic type definition</h2>
<p>First, let's start with the type definition. Like mentioned above, we want to
represent a stream of T as a nullable pair of some value T and a function that
produces the next value of the stream T. A <code>nil</code> stream represents an empty
stream.</p>
<p>Go doesn't directly support pairs, so we're going to use a struct here:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">type Stream[T any] struct {
	Value T
	Next  func() *Stream[T]
}
</code></pre>
<p>And we'll represent streams as pointers to that struct, which takes care of the
<code>nullable</code> part.</p>
<p>It looks like a linked-list, but since we want to be able to represent a
potentially infinite linked list, instead of making <code>Next</code> a pointer to Stream,
we make it a function that returns the pointer, and lazily execute that
function as needed.</p>
<h2 id="creating-streams">Creating streams</h2>
<p>First, let's start with some very basic streams: an empty stream, and a
singleton stream (that contains a single element). We'll use helper functions
to implement those:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func Empty[T any]() *Stream[T] {
	return nil
}

func Singleton[T any](element T) *Stream[T] {
	return &amp;Stream[T]{
		Value: element,
		Next:  Empty[T],
	}
}
</code></pre>
<p>A more interesting helper function is a function that takes a slice and returns
a stream with the elements of that slice:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func FromSlice[T any](items []T) *Stream[T] {
	if len(items) == 0 {
		return nil
	}
	return &amp;Stream[T]{
		Value: items[0],
		Next: func() *Stream[T] {
			return FromSlice(items[1:])
		},
	}
}
</code></pre>
<p>To keep the context around of where we are in the slice as the stream is
consumed, we introduce a helper function that takes the index that we want to
consume in the slice, and <code>FromSlice</code> invokes that helper function starting at
index 0. The stream becomes nil as soon as the index grows too large,
indicating that we finished iterating over the slice.</p>
<h3 id="infinite-streams">Infinite streams</h3>
<p>Using a slice is no fun, we probably want to be able to implement streams that
are potentially infinite. For example, a stream of natural numbers could be
represented as follows:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func nat(start int) *Stream[int] {
	return &amp;Stream[int]{
		Value: start,
		Next: func() *Stream[int] {
			return nat(start + 1)
		},
	}
}
</code></pre>
<p>Here is where the limitation with Go's type inference starts to show: since it
can't infer return types, we have to manually specify <code>Stream[int]</code> in multiple
places.</p>
<p>Note how we never return <code>nil</code> in the function above, indicating that this
stream doesn't really end.</p>
<h2 id="manipulating-streams">Manipulating streams</h2>
<p>Now that we know how to create them, we need to understand how to manipulate
them to accomplish something useful. Two useful helper functions, useful for
debugging and what not, are <code>Iter</code> and <code>ToSlice</code>: <code>Iter</code> takes a stream and a
function, and iterates over the stream, invoking the function for each element,
while <code>ToSlice</code> converts a stream to a slice.</p>
<p>Here's <code>Iter</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func Iter[T any](stream *Stream[T], f func(T)) {
	for ; stream != nil; stream = stream.Next() {
		f(stream.Value)
	}
}
</code></pre>
<p>And here's <code>ToSlice</code>, built on top of <code>Iter</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func ToSlice[T any](stream *Stream[T]) []T {
	var result []T
	Iter(stream, func(value T) {
		result = append(result, value)
	})
	return result
}
</code></pre>
<p>(folks who are paying attention will probably suggest that we use something
like <code>Fold</code> instead of <code>Iter</code> to implement <code>ToSlice</code>, we'll get there).</p>
<p>And now that we have <code>Iter</code> and an infinite stream, we should try to use it
maybe? :)</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func main() {
	Iter(nat(0), func(v int) {
		fmt.Println(v)
	})
}
</code></pre>
<p>This is a very fancy way of making an infinite loop :)</p>
<h2 id="higher-order-functions">Higher-order functions</h2>
<p>Higher-order functions make streams more interesting. There are many possible
high-order functions, but we'll explore some common names here: <code>Map</code>, <code>Filter</code>
and <code>Fold</code> (<code>Fold</code> may also be called <code>Reduce</code> in other contexts). Then we'll
do a fun one with <code>FlatMap</code>.</p>
<blockquote>
<p><strong>Note:</strong> different from actual lists/arrays, with streams one can't
implement <code>Map</code> or <code>Filter</code> using <code>Fold</code>, as <code>Fold</code> always consumes the
stream.</p>
</blockquote>
<p>The interesting thing with streams is that functions such as <code>Filter</code> and <code>Map</code>
don't do any computation unless needed: streams are lazy by nature, and actual
computations only happen when they're consumed.</p>
<h3 id="map">Map</h3>
<p><code>Map</code> takes a stream of type <code>T</code> and a function from <code>T</code> to <code>U</code> and returns a
stream of <code>U</code>. Here's the implementation of <code>Map</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func Map[T, U any](stream *Stream[T], f func(T) U) *Stream[U] {
	if stream == nil {
		return nil
	}
	return &amp;Stream[U]{
		Value: f(stream.Value),
		Next: func() *Stream[U] {
			return Map(stream.Next(), f)
		},
	}
}
</code></pre>
<p>How can we use <code>Map</code>? A simple/stupid example would be to double all numbers
from the <code>nat</code> stream to get a stream of even numbers:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func main() {
	evens := Map(nat(0), func(v int) int {
		return v * 2
	})
	Iter(evens, func(v int) {
		fmt.Println(v)
	})
}
</code></pre>
<h3 id="filter">Filter</h3>
<p><code>Filter</code> takes a stream of type <code>T</code> and a predicate function from <code>T</code> to <code>bool</code>
and returns a new stream of <code>T</code>, containing only the elements of the original
stream for which the given predicate returns <code>true</code>. Here's the implementation
of <code>filter</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func Filter[T any](stream *Stream[T], f func(T) bool) *Stream[T] {
	for ; stream != nil; stream = stream.Next() {
		if f(stream.Value) {
			return &amp;Stream[T]{
				Value: stream.Value,
				Next: func() *Stream[T] {
					return Filter(stream.Next(), f)
				},
			}
		}
	}
	return stream
}
</code></pre>
<p>Since a non-nil Stream is required to have a valid element, <code>Filter</code> isn't
totally lazy, as it has to consume the source stream until the predicate <code>p</code>
returns <code>true</code>. Here's how we can get a stream of even numbers using <code>Filter</code>
instead of <code>Map</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func main() {
	evens := Filter(nat(0), func(v int) bool {
		return v%2 == 0
	})
	Iter(evens, func(v int) {
		fmt.Println(v)
	})
}
</code></pre>
<h3 id="fold">Fold</h3>
<p><code>Fold</code> can be used to eagerly fold the elements of a stream into some other
value. For example, if you have a finite stream of integers, you could use
<code>Fold</code> to find the largest, the smallest or the sum of all elements in the
stream.</p>
<p>Since <code>Fold</code> is eager, it can't really operate on infinite streams, as that
would loop forever. Let's look at the implementation of <code>Fold</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func Fold[T, U any](stream *Stream[T], init U, f func(U, T) U) U {
	acc := init
	for ; stream != nil; stream = stream.Next() {
		acc = f(acc, stream.Value)
	}
	return acc
}
</code></pre>
<p>And here's an implementation of <code>ToSlice</code> that uses <code>Fold</code> instead of <code>Iter</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func ToSlice[T any](stream *Stream[T]) []T {
	return Fold(stream, []T{}, func(acc []T, elm T) []T {
		return append(acc, elm)
	})
}
</code></pre>
<h3 id="flatmap">FlatMap</h3>
<p><code>FlatMap</code> works like <code>Map</code>, but instead of taking a function from <code>T</code> to <code>U</code>,
it takes a function from <code>T</code> to <code>Stream[U]</code>. In order to implement <code>FlatMap</code>,
we'll first implement another useful function: <code>Append</code>, which takes two
streams <code>s1</code> and <code>s2</code> and returns a stream that will have all elements from
<code>s1</code>, then all elements from <code>s2</code>. Here's the code for both <code>Append</code> and
<code>FlatMap</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func Append[T any](stream1 *Stream[T], stream2 *Stream[T]) *Stream[T] {
	if stream1 == nil {
		return stream2
	}
	return &amp;Stream[T]{
		Value: stream1.Value,
		Next: func() *Stream[T] {
			return Append(stream1.Next(), stream2)
		},
	}
}

func FlatMap[T, U any](stream *Stream[T], f func(T) *Stream[U]) *Stream[U] {
	if stream == nil {
		return nil
	}
	return Append(f(stream.Value), FlatMap(stream.Next(), f))
}
</code></pre>
<p>One simple-ish example is taking a stream of strings and turning that into a
stream of runes:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">var s *Stream[string] = ...
FlatMap(s, func(v string) *Stream[rune] {
	return FromSlice([]rune(v))
})
</code></pre>
<h2 id="slicing-streams">Slicing streams</h2>
<p>On top of filtering, mapping, appending and others, one may want to combine
multiple streams (using <code>Append</code> declared above), or get some elements of a
stream, or drop some items from a stream. For that, let's look at how we'd
implement some other helper functions:</p>
<ul>
<li><code>Take(s Stream[T], n int) Stream[T]</code>: given stream <code>s</code>, returns a new stream
with at most <code>n</code> elements.</li>
<li><code>TakeWhile(s Stream[T], p func(T) bool) Stream[T]</code>: given stream <code>s</code> and a
predicate <code>p</code>, returns a new stream that will have elements from <code>s</code> as long
as <code>p</code> returns <code>true</code></li>
<li><code>TakeUntil(s Stream[T], p func(T) bool) Stream[T]</code>: like <code>TakeWhile</code>, but the
output stream will have elements from <code>s</code> until <code>p</code> returns <code>true</code>.</li>
</ul>
<p>Here's the source for <code>Take</code>, <code>TakeWhile</code> and <code>TakeUntil</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func Take[T any](stream *Stream[T], n uint) *Stream[T] {
	if n == 0 || stream == nil {
		return nil
	}
	return &amp;Stream[T]{
		Value: stream.Value,
		Next: func() *Stream[T] {
			return Take(stream.Next(), n-1)
		},
	}
}

func TakeWhile[T any](stream *Stream[T], f func(T) bool) *Stream[T] {
	if stream == nil {
		return nil
	}
	if f(stream.Value) {
		return &amp;Stream[T]{
			Value: stream.Value,
			Next: func() *Stream[T] {
				return TakeWhile(stream.Next(), f)
			},
		}
	}
	return nil
}

func TakeUntil[T any](stream *Stream[T], f func(T) bool) *Stream[T] {
	return TakeWhile(stream, func(v T) bool { return !f(v) })
}
</code></pre>
<p>Notice how <code>TakeUntil</code> is simply implemented in terms of <code>TakeWhile</code>. As a
matter of fact, <code>Take</code> could also be implemented with <code>TakeWhile</code> and a
closure:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func Take[T any](stream *Stream[T], n uint) *Stream[T] {
	return TakeWhile(stream, func(T) bool {
		if n == 0 {
			return false
		}
		n--
		return true
	})
}
</code></pre>
<h2 id="putting-it-all-together-in-a-realistic-example">Putting it all together in a realistic example</h2>
<p>Let's do a very simple REPL style application: it has a shell where we can
enter commands, and those commands will have some side-effect. Let's implement
a poor man <a rel="noopener" target="_blank" href="https://memcached.org/">memcached</a> that operates via stdin, and
supports three commands <code>set</code>, <code>get</code> and <code>del</code> (which will set a key-value
pair, get the value of a key and delete a key, respectively). We want to be
able to have two separate layers: one for parsing and another one for executing
commands, and we want to be able to send commands from stdin to the execution
layer.</p>
<p>This is an extremely simple example that doesn't <em>really</em> need generics (it's
stringly-typed :D), but should give an idea of how functional streams can be
used.</p>
<p>First, let's introduce a helper function that allow us to generate a lines
stream from an <code>io.Reader</code>:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func FromReader(r io.Reader) *Stream[string] {
	return fromReader(bufio.NewReader(r))
}

func fromReader(r *bufio.Reader) *Stream[string] {
	line, isPrefix, err := r.ReadLine()
	if err != nil {
		return nil
	}
	parts := []string{string(line)}
	for isPrefix {
		line, isPrefix, err = r.ReadLine()
		if err != nil {
			return nil
		}
		parts = append(parts, string(line))
	}
	return &amp;Stream[string]{
		Value: strings.Join(parts, &quot;&quot;),
		Next: func() *Stream[string] {
			return fromReader(r)
		},
	}
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> that we're eating errors here, just another demonstration that you
shouldn't do this in production, at least not the way it's described in this
blog post :)</p>
<p>The code below will also not handle any errors. Don't do this at home.</p>
</blockquote>
<p>Now that we have that function, we can create our &quot;database&quot; instance, loop
through the input and execute commands:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func ProcessCommands(input io.Reader, output io.Writer) {
	s := stream.FromReader(input)
	stream.Fold(s, NewDB(output), func(db *DB, line string) *DB {
		cmd := strings.Fields(line)
		db.Execute(cmd[0], cmd[1:])
		return db
	})
}
</code></pre>
<p>(for runnable code, checkout the <a rel="noopener" target="_blank" href="https://github.com/fsouza/blog/blob/main/content/2022-02-12-functional-streams-in-go/stream/kvdb/kvdb.go">GitHub
repository</a>)</p>
<h3 id="another-more-interesting-example">Another more interesting example</h3>
<p>A less realistic, but interesting example is taking a stream of numbers from
stdin, parse them, and sum all the prime numbers. This requires using the
helper <code>FromReader</code>, <code>Map</code> to parse the number, <code>Filter</code> to discard non-prime
numbers and <code>Fold</code> to sum the filtered values. Notice that this is stdin, so
values are getting piped through as they are read from stdin.</p>
<p>Here's what that &quot;pipeline&quot; looks like:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func main() {
	stdin := stream.FromReader(os.Stdin)
	numbers := stream.Map(stdin, parseLine)
	primes := stream.Filter(numbers, isPrime)
	sum := stream.Fold(primes, 0, sum)
	fmt.Println(sum)
}
</code></pre>
<p>(again, for runnable code, checkout the GitHub repo)</p>
<h2 id="why-not-methods">Why not methods?</h2>
<p><strong>TL;DR:</strong> Go doesn't really support it. <a rel="noopener" target="_blank" href="https://github.com/golang/go/issues/43390">It may in the
future</a>.</p>
<p>One thing one may notice from the example above is that using functions makes
the code quite verbose, we have to introduce variables for intermediary streams
(or we could nest function calls).
Functional languages get away with that by having some sort of function
composition or using pipe operators / threading macros. But in more
object-oriented languages, methods are used, which is a better fit for Go. So the code below:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">stdin := stream.FromReader(os.Stdin)
numbers := stream.Map(stdin, parseLine)
primes := stream.Filter(numbers, isPrime)
sum := stream.Fold(primes, 0, sum)
</code></pre>
<p>Could become something like:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">sum := stream.FromReader(os.Stdin).Map(parseLine).Filter(isPrime).Fold(0, sum)
</code></pre>
<p>Why can't we do that in Go? The problem is that methods can't really be generic
in Go, it's not currently supported by the generics implementation, which means
the <code>Map</code> method in the pipeline above cannot be implemented. It's an issues
with how methods are used for structural subtyping &amp; interfaces, so it may be
complicated to address or not happen at hall. See the <a rel="noopener" target="_blank" href="https://github.com/golang/go/issues/43390">issue in the Go issue
tracker for more details</a>!</p>
<h2 id="feedback">Feedback</h2>
<p>Do you have any feedback? Questions? Concerns? Wanna fix a typo? Checkout the
<a rel="noopener" target="_blank" href="https://github.com/fsouza/blog/blob/HEAD/content/2022-02-12-functional-streams-in-go/index.md">source for this post in
GitHub</a>
(feel free to send a PR), or the <a rel="noopener" target="_blank" href="https://github.com/fsouza/blog/discussions/12">discussion in the GitHub
repo</a>.</p>

</div>

<!-- prettier ignore -->

        </div>

         
    </body>
</html>
