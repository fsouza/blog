<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Francisco Souza</title>
	<link href="https://blog.fsouza.dev/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://blog.fsouza.dev"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-02-12T00:00:00+00:00</updated>
	<id>https://blog.fsouza.dev/atom.xml</id>
	<entry xml:lang="en">
		<title>Implementing functional streams with generics in Go</title>
		<published>2022-02-12T00:00:00+00:00</published>
		<updated>2022-02-12T00:00:00+00:00</updated>
		<link href="https://blog.fsouza.dev/functional-streams-in-go/" type="text/html"/>
		<id>https://blog.fsouza.dev/functional-streams-in-go/</id>
		<content type="html">&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#x27;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#the-basic-type-definition&quot;&gt;The basic type definition&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#creating-streams&quot;&gt;Creating streams&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#infinite-streams&quot;&gt;Infinite streams&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#manipulating-streams&quot;&gt;Manipulating streams&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#higher-order-functions&quot;&gt;Higher-order functions&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#map&quot;&gt;Map&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#filter&quot;&gt;Filter&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#fold&quot;&gt;Fold&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#flatmap&quot;&gt;FlatMap&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#combining-and-slicing-streams&quot;&gt;Combining and slicing streams&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#take-takewhile-and-takeuntil&quot;&gt;Take, TakeWhile and TakeUntil&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#drop-dropwhile-and-dropuntil&quot;&gt;Drop, DropWhile and DropUntil&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#putting-it-all-together-in-a-realistic-example&quot;&gt;Putting it all together in a realistic example&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#another-more-interesting-example&quot;&gt;Another more interesting example&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#why-not-methods&quot;&gt;Why not methods?&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;functional-streams-in-go&#x2F;#feedback&quot;&gt;Feedback&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note 1:&lt;&#x2F;strong&gt; this is an experiment with an upcoming change in Go&#x27;s type system.
If you need something like what&#x27;s described in the post in the real world,
use channels, or something like RxGo.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Note 2:&lt;&#x2F;strong&gt; I originally started this post in August and almost abandoned it,
but figured it&#x27;s still a useful exploration of an important upcoming feature
use channels, or something like RxGo.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Go 1.18 will support generics, and I decided I would give it a shot. I&#x27;ve been
playing with the idea of &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;channels&quot;&gt;representing streams with
channels&lt;&#x2F;a&gt; and higher order functions that
operate on those channels, allowing processes to execute on streams of data
somewhat-lazily. This is 100% a toy project and a production-ready version of
&amp;quot;lazy&#x2F;generic streams&amp;quot; will likely come in some future release of
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ReactiveX&#x2F;RxGo&quot;&gt;RxGo&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Still, while working on a solution to get this working with channels, I figured
we could also try to get it working in a more traditional representation, at
least in functional languages: streams can be represented by a pair - a value
and a function to generate the next value.&lt;&#x2F;p&gt;
&lt;p&gt;I started with a question: with generics, is the Go type-system expressive
enough to represent such streams. And how bad would it look without Ocaml&#x27;s or
Haskell&#x27;s type inference capabilities? Turns out we &lt;em&gt;can&lt;&#x2F;em&gt; represent streams,
and the limited type-inference makes it a bit annoying, but it isn&#x27;t too bad!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-basic-type-definition&quot;&gt;The basic type definition&lt;&#x2F;h2&gt;
&lt;p&gt;First, let&#x27;s start with the type definition. Like mentioned above, we want to
represent a stream of T as a nullable pair of some value T and a function that
produces the next value of the stream T. A &lt;code&gt;nil&lt;&#x2F;code&gt; stream represents an empty
stream.&lt;&#x2F;p&gt;
&lt;p&gt;Go doesn&#x27;t directly support pairs, so we&#x27;re going to use a struct here:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type Stream[T any] struct {
	Value T
	Next  func() *Stream[T]
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And we&#x27;ll represent streams as pointers to that struct, which takes care of the
&lt;code&gt;nullable&lt;&#x2F;code&gt; part.&lt;&#x2F;p&gt;
&lt;p&gt;It looks like a linked-list, but since we want to be able to represent a
potentially infinite linked list, instead of making &lt;code&gt;Next&lt;&#x2F;code&gt; a pointer to Stream,
we make it a function that returns the pointer, and lazily execute that
function as needed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-streams&quot;&gt;Creating streams&lt;&#x2F;h2&gt;
&lt;p&gt;First, let&#x27;s start with some very basic streams: an empty stream, and a
singleton stream (that contains a single element). We&#x27;ll use helper functions
to implement those:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func Empty[T any]() *Stream[T] {
	return nil
}

func Singleton[T any](element T) *Stream[T] {
	return &amp;amp;Stream[T]{
		Value: element,
		Next:  Empty[T],
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A more interesting helper function is a function that takes a slice and returns
a stream with the elements of that slice:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func FromSlice[T any](items []T) *Stream[T] {
	if len(items) == 0 {
		return nil
	}
	return &amp;amp;Stream[T]{
		Value: items[0],
		Next: func() *Stream[T] {
			return FromSlice(items[1:])
		},
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To keep the context around of where we are in the slice as the stream is
consumed, we introduce a helper function that takes the index that we want to
consume in the slice, and &lt;code&gt;FromSlice&lt;&#x2F;code&gt; invokes that helper function starting at
index 0. The stream becomes nil as soon as the index grows too large,
indicating that we finished iterating over the slice.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;infinite-streams&quot;&gt;Infinite streams&lt;&#x2F;h3&gt;
&lt;p&gt;Using a slice is no fun, we probably want to be able to implement streams that
are potentially infinite. For example, a stream of natural numbers could be
represented as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func nat(start int) *Stream[int] {
	return &amp;amp;Stream[int]{
		Value: start,
		Next: func() *Stream[int] {
			return nat(start + 1)
		},
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here is where the limitation with Go&#x27;s type inference starts to show: since it
can&#x27;t infer return types, we have to manually specify &lt;code&gt;Stream[int]&lt;&#x2F;code&gt; in multiple
places.&lt;&#x2F;p&gt;
&lt;p&gt;Note how we never return &lt;code&gt;nil&lt;&#x2F;code&gt; in the function above, indicating that this
stream doesn&#x27;t really end.&lt;&#x2F;p&gt;
&lt;p&gt;One potentially&lt;&#x2F;p&gt;
&lt;h2 id=&quot;manipulating-streams&quot;&gt;Manipulating streams&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we know how to create them, we need to understand how to manipulate
them to accomplish something useful. Two useful helper functions, useful for
debugging and what not, are &lt;code&gt;Iter&lt;&#x2F;code&gt; and &lt;code&gt;ToSlice&lt;&#x2F;code&gt;: &lt;code&gt;Iter&lt;&#x2F;code&gt; takes a stream and a
function, and iterates over the stream, invoking the function for each element,
while &lt;code&gt;ToSlice&lt;&#x2F;code&gt; converts a stream to a slice.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s &lt;code&gt;Iter&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func Iter[T any](stream *Stream[T], f func(T)) {
	for ; stream != nil; stream = stream.Next() {
		f(stream.Value)
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And here&#x27;s &lt;code&gt;ToSlice&lt;&#x2F;code&gt;, built on top of &lt;code&gt;Iter&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func ToSlice[T any](stream *Stream[T]) []T {
	var result []T
	Iter(stream, func(value T) {
		result = append(result, value)
	})
	return result
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(folks who are paying attention will probably suggest that we use something
like &lt;code&gt;Fold&lt;&#x2F;code&gt; instead of &lt;code&gt;Iter&lt;&#x2F;code&gt; to implement &lt;code&gt;ToSlice&lt;&#x2F;code&gt;, we&#x27;ll get there).&lt;&#x2F;p&gt;
&lt;p&gt;And now that we have &lt;code&gt;Iter&lt;&#x2F;code&gt; and an infinite stream, we should try to use it
maybe? :)&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func main() {
	Iter(nat(0), func(v int) {
		fmt.Println(v)
	})
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a very fancy way of making an infinite loop :)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;higher-order-functions&quot;&gt;Higher-order functions&lt;&#x2F;h2&gt;
&lt;p&gt;Higher-order functions make streams more interesting. There are many possible
high-order functions, but we&#x27;ll explore some common names here: &lt;code&gt;Map&lt;&#x2F;code&gt;, &lt;code&gt;Filter&lt;&#x2F;code&gt;
and &lt;code&gt;Fold&lt;&#x2F;code&gt; (&lt;code&gt;Fold&lt;&#x2F;code&gt; may also be called &lt;code&gt;Reduce&lt;&#x2F;code&gt; in other contexts). Then we&#x27;ll
do a fun one with &lt;code&gt;FlatMap&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; different from actual lists&#x2F;arrays, with streams one can&#x27;t
implement &lt;code&gt;Map&lt;&#x2F;code&gt; or &lt;code&gt;Filter&lt;&#x2F;code&gt; using &lt;code&gt;Fold&lt;&#x2F;code&gt;, as &lt;code&gt;Fold&lt;&#x2F;code&gt; always consumes the
stream.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The interesting thing with streams is that functions such as &lt;code&gt;Filter&lt;&#x2F;code&gt; and &lt;code&gt;Map&lt;&#x2F;code&gt;
don&#x27;t do any computation unless needed: streams are lazy by nature, and actual
computations only happen when they&#x27;re consumed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;map&quot;&gt;Map&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;Map&lt;&#x2F;code&gt; takes a stream of type &lt;code&gt;T&lt;&#x2F;code&gt; and a function from &lt;code&gt;T&lt;&#x2F;code&gt; to &lt;code&gt;U&lt;&#x2F;code&gt; and returns a
stream of &lt;code&gt;U&lt;&#x2F;code&gt;. Here&#x27;s the implementation of &lt;code&gt;Map&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func Map[T, U any](stream *Stream[T], f func(T) U) *Stream[U] {
	if stream == nil {
		return nil
	}
	return &amp;amp;Stream[U]{
		Value: f(stream.Value),
		Next: func() *Stream[U] {
			return Map(stream.Next(), f)
		},
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;How can we use &lt;code&gt;Map&lt;&#x2F;code&gt;? A simple&#x2F;stupid example would be to double all numbers
from the &lt;code&gt;nat&lt;&#x2F;code&gt; stream to get a stream of even numbers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func main() {
	evens := Map(nat(0), func(v int) int {
		return v * 2
	})
	Iter(evens, func(v int) {
		fmt.Println(v)
	})
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;filter&quot;&gt;Filter&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;Filter&lt;&#x2F;code&gt; takes a stream of type &lt;code&gt;T&lt;&#x2F;code&gt; and a predicate function from &lt;code&gt;T&lt;&#x2F;code&gt; to &lt;code&gt;bool&lt;&#x2F;code&gt;
and returns a new stream of &lt;code&gt;T&lt;&#x2F;code&gt;, containing only the elements of the original
stream for which the given predicate returns &lt;code&gt;true&lt;&#x2F;code&gt;. Here&#x27;s the implementation
of &lt;code&gt;filter&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func Filter[T any](stream *Stream[T], f func(T) bool) *Stream[T] {
	for ; stream != nil; stream = stream.Next() {
		if f(stream.Value) {
			return &amp;amp;Stream[T]{
				Value: stream.Value,
				Next: func() *Stream[T] {
					return Filter(stream.Next(), f)
				},
			}
		}
	}
	return stream
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since a non-nil Stream is required to have a valid element, &lt;code&gt;Filter&lt;&#x2F;code&gt; isn&#x27;t
totally lazy, as it has to consume the source stream until the predicate &lt;code&gt;p&lt;&#x2F;code&gt;
returns &lt;code&gt;true&lt;&#x2F;code&gt;. Here&#x27;s how we can get a stream of even numbers using &lt;code&gt;Filter&lt;&#x2F;code&gt;
instead of &lt;code&gt;Map&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func main() {
	evens := Filter(nat(0), func(v int) bool {
		return v%2 == 0
	})
	Iter(evens, func(v int) {
		fmt.Println(v)
	})
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fold&quot;&gt;Fold&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;Fold&lt;&#x2F;code&gt; can be used to eagerly fold the elements of a stream into some other
value. For example, if you have a finite stream of integers, you could use
&lt;code&gt;Fold&lt;&#x2F;code&gt; to find the largest, the smallest or the sum of all elements in the
stream.&lt;&#x2F;p&gt;
&lt;p&gt;Since &lt;code&gt;Fold&lt;&#x2F;code&gt; is eager, it can&#x27;t really operate on infinite streams, as that
would loop forever. Let&#x27;s look at the implementation of &lt;code&gt;Fold&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func Fold[T, U any](stream *Stream[T], init U, f func(U, T) U) U {
	acc := init
	for ; stream != nil; stream = stream.Next() {
		acc = f(acc, stream.Value)
	}
	return acc
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And here&#x27;s an implementation of &lt;code&gt;ToSlice&lt;&#x2F;code&gt; that uses &lt;code&gt;Fold&lt;&#x2F;code&gt; instead of &lt;code&gt;Iter&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func ToSlice[T any](stream *Stream[T]) []T {
	return Fold(stream, []T{}, func(acc []T, elm T) []T {
		return append(acc, elm)
	})
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flatmap&quot;&gt;FlatMap&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;FlatMap&lt;&#x2F;code&gt; works like &lt;code&gt;Map&lt;&#x2F;code&gt;, but instead of taking a function from &lt;code&gt;T&lt;&#x2F;code&gt; to &lt;code&gt;U&lt;&#x2F;code&gt;,
it takes a function from &lt;code&gt;T&lt;&#x2F;code&gt; to &lt;code&gt;Stream[U]&lt;&#x2F;code&gt;. In order to implement &lt;code&gt;FlatMap&lt;&#x2F;code&gt;,
we&#x27;ll first implement another useful function: &lt;code&gt;Append&lt;&#x2F;code&gt;, which takes two
streams &lt;code&gt;s1&lt;&#x2F;code&gt; and &lt;code&gt;s2&lt;&#x2F;code&gt; and returns a stream that will have all elements from
&lt;code&gt;s1&lt;&#x2F;code&gt;, then all elements from &lt;code&gt;s2&lt;&#x2F;code&gt;. Here&#x27;s the code for both &lt;code&gt;Append&lt;&#x2F;code&gt; and
&lt;code&gt;FlatMap&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func Append[T any](stream1 *Stream[T], stream2 *Stream[T]) *Stream[T] {
	if stream1 == nil {
		return stream2
	}
	return &amp;amp;Stream[T]{
		Value: stream1.Value,
		Next: func() *Stream[T] {
			return Append(stream1.Next(), stream2)
		},
	}
}

func FlatMap[T, U any](stream *Stream[T], f func(T) *Stream[U]) *Stream[U] {
	if stream == nil {
		return nil
	}
	return Append(f(stream.Value), FlatMap(stream.Next(), f))
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;One simple-ish example is taking a stream of strings and turning that into a
stream of runes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;var s *Stream[string] = ...
FlatMap(s, func(v string) *Stream[rune] {
	return FromSlice([]rune(v))
})
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;combining-and-slicing-streams&quot;&gt;Combining and slicing streams&lt;&#x2F;h2&gt;
&lt;p&gt;On top of filtering, mapping, appending and others, one may want to combine
multiple streams, or get some elements of a stream, or drop some items from a
stream. For that, let&#x27;s look at how we&#x27;d implement some other helper functions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Take(s Stream[T], n int) Stream[T]&lt;&#x2F;code&gt;: given stream &lt;code&gt;s&lt;&#x2F;code&gt;, returns a new stream
with at most &lt;code&gt;n&lt;&#x2F;code&gt; elements.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;TakeWhile(s Stream[T], p func(T) bool) Stream[T]&lt;&#x2F;code&gt;: given stream &lt;code&gt;s&lt;&#x2F;code&gt; and a
predicate &lt;code&gt;p&lt;&#x2F;code&gt;, returns a new stream that will have elements from &lt;code&gt;s&lt;&#x2F;code&gt; as long
as &lt;code&gt;p&lt;&#x2F;code&gt; returns &lt;code&gt;true&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;TakeUntil(s Stream[T], p func(T) bool) Stream[T]&lt;&#x2F;code&gt;: like &lt;code&gt;TakeWhile&lt;&#x2F;code&gt;, but the
output stream will have elements from &lt;code&gt;s&lt;&#x2F;code&gt; until &lt;code&gt;p&lt;&#x2F;code&gt; returns &lt;code&gt;true&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Drop(s Stream[T], n int) Stream[T]&lt;&#x2F;code&gt;: given stream &lt;code&gt;s&lt;&#x2F;code&gt;, returns a new stream
that doesn&#x27;t include the first &lt;code&gt;n&lt;&#x2F;code&gt; elements of &lt;code&gt;s&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;DropWhile(s Stream[T], p func(T) bool) Stream[T]&lt;&#x2F;code&gt;: given stream &lt;code&gt;s&lt;&#x2F;code&gt; and a
predicate &lt;code&gt;p&lt;&#x2F;code&gt;, returns a new stream that will skip elements from &lt;code&gt;s&lt;&#x2F;code&gt; as long
as &lt;code&gt;p&lt;&#x2F;code&gt; returns &lt;code&gt;true&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;DropUntil(s Stream[T], p func(T) bool) Stream[T]&lt;&#x2F;code&gt;: like &lt;code&gt;DropWhile&lt;&#x2F;code&gt;, but the
output stream will skip elements from &lt;code&gt;s&lt;&#x2F;code&gt; until &lt;code&gt;p&lt;&#x2F;code&gt; returns &lt;code&gt;true&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;take-takewhile-and-takeuntil&quot;&gt;Take, TakeWhile and TakeUntil&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;drop-dropwhile-and-dropuntil&quot;&gt;Drop, DropWhile and DropUntil&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;putting-it-all-together-in-a-realistic-example&quot;&gt;Putting it all together in a realistic example&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s do a very simple REPL style application: it has a shell where we can
enter commands, and those commands will have some side-effect. Let&#x27;s implement
a poor man &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;memcached.org&#x2F;&quot;&gt;memcached&lt;&#x2F;a&gt; that operates via stdin, and
supports three commands &lt;code&gt;set&lt;&#x2F;code&gt;, &lt;code&gt;get&lt;&#x2F;code&gt; and &lt;code&gt;del&lt;&#x2F;code&gt; (which will set a key-value
pair, get the value of a key and delete a key, respectively). We want to be
able to have two separate layers: one for parsing and another one for executing
commands, and we want to be able to send commands from stdin to the execution
layer.&lt;&#x2F;p&gt;
&lt;p&gt;This is an extremely simple example that doesn&#x27;t &lt;em&gt;really&lt;&#x2F;em&gt; need generics (it&#x27;s
stringly-typed :D), but should give an idea of how functional streams can be
used.&lt;&#x2F;p&gt;
&lt;p&gt;First, let&#x27;s introduce a helper function that allow us to generate a lines
stream from an &lt;code&gt;io.Reader&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func FromReader(r io.Reader) *Stream[string] {
	return fromReader(bufio.NewReader(r))
}

func fromReader(r *bufio.Reader) *Stream[string] {
	line, isPrefix, err := r.ReadLine()
	if err != nil {
		return nil
	}
	parts := []string{string(line)}
	for isPrefix {
		line, isPrefix, err = r.ReadLine()
		if err != nil {
			return nil
		}
		parts = append(parts, string(line))
	}
	return &amp;amp;Stream[string]{
		Value: strings.Join(parts, &amp;quot;&amp;quot;),
		Next: func() *Stream[string] {
			return fromReader(r)
		},
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; that we&#x27;re eating errors here, just another demonstration that you
shouldn&#x27;t do this in production, at least not the way it&#x27;s described in this
blog post :)&lt;&#x2F;p&gt;
&lt;p&gt;The code below will also not handle any errors. Don&#x27;t do this at home.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Now that we have that function, we can create our &amp;quot;database&amp;quot; instance, loop
through the input and execute commands:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func ProcessCommands(input io.Reader, output io.Writer) {
	s := stream.FromReader(input)
	stream.Fold(s, NewDB(output), func(db *DB, line string) *DB {
		cmd := strings.Fields(line)
		db.Execute(cmd[0], cmd[1:])
		return db
	})
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(for runnable code, checkout the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;blog&#x2F;blob&#x2F;main&#x2F;content&#x2F;2022-02-12-functional-streams-in-go&#x2F;stream&#x2F;kvdb&#x2F;kvdb.go&quot;&gt;GitHub
repository&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;h3 id=&quot;another-more-interesting-example&quot;&gt;Another more interesting example&lt;&#x2F;h3&gt;
&lt;p&gt;A less realistic, but interesting example is taking a stream of numbers from
stdin, parse them, and sum all the prime numbers. This requires using the
helper &lt;code&gt;FromReader&lt;&#x2F;code&gt;, &lt;code&gt;Map&lt;&#x2F;code&gt; to parse the number, &lt;code&gt;Filter&lt;&#x2F;code&gt; to discard non-prime
numbers and &lt;code&gt;Fold&lt;&#x2F;code&gt; to sum the filtered values. Notice that this is stdin, so
values are getting piped through as they are read from stdin.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s what that &amp;quot;pipeline&amp;quot; looks like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func main() {
	stdin := stream.FromReader(os.Stdin)
	numbers := stream.Map(stdin, parseLine)
	primes := stream.Filter(numbers, isPrime)
	sum := stream.Fold(primes, 0, sum)
	fmt.Println(sum)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(again, for runnable code, checkout the GitHub repo)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-not-methods&quot;&gt;Why not methods?&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;TL;DR:&lt;&#x2F;strong&gt; Go doesn&#x27;t really support it. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;43390&quot;&gt;It may in the
future&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;One thing one may notice from the example above is that using functions makes
the code quite verbose, we have to introduce variables for intermediary streams
(or we could nest function calls).
Functional languages get away with that by having some sort of function
composition or using pipe operators &#x2F; threading macros. But in more
object-oriented languages, methods are used, which is a better fit for Go. So the code below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;stdin := stream.FromReader(os.Stdin)
numbers := stream.Map(stdin, parseLine)
primes := stream.Filter(numbers, isPrime)
sum := stream.Fold(primes, 0, sum)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Could become something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;sum := stream.FromReader(os.Stdin).Map(parseLine).Filter(isPrime).Fold(0, sum)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Why can&#x27;t we do that in Go? The problem is that methods can&#x27;t really be generic
in Go, it&#x27;s not currently supported by the generics implementation, which mean
the &lt;code&gt;Map&lt;&#x2F;code&gt; function in the pipeline below cannot be implemented. It&#x27;s an issues
with how methods are used for structural subtyping &amp;amp; interfaces, so it may be
complicated to address or not happen at hall. See the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;43390&quot;&gt;issue in the Go issue
tracker for more details&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;feedback&quot;&gt;Feedback&lt;&#x2F;h2&gt;
&lt;p&gt;Do you have any feedback? Questions? Concerns? Wanna fix a typo? Checkout the
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;blog&#x2F;blob&#x2F;HEAD&#x2F;content&#x2F;2022-02-12-functional-streams-in-go&#x2F;index.md&quot;&gt;source for this post in
GitHub&lt;&#x2F;a&gt;
(feel free to send a PR), or the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;blog&#x2F;discussions&#x2F;12&quot;&gt;discussion in the GitHub
repo&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Making format-on-save fast with prettierd</title>
		<published>2021-02-12T00:00:00+00:00</published>
		<updated>2021-02-12T00:00:00+00:00</updated>
		<link href="https://blog.fsouza.dev/prettierd-neovim-format-on-save/" type="text/html"/>
		<id>https://blog.fsouza.dev/prettierd-neovim-format-on-save/</id>
		<content type="html">&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#x27;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;prettierd-neovim-format-on-save&#x2F;#intro&quot;&gt;Intro&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;prettierd-neovim-format-on-save&#x2F;#who-cares&quot;&gt;Who cares?!&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;prettierd-neovim-format-on-save&#x2F;#my-visual-studio-code-doesn-t-take-a-second-to-format-on-save-your-vim-is-trash&quot;&gt;&amp;quot;My Visual Studio Code doesn&#x27;t take a second to format-on-save, your Vim is trash&amp;quot;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;prettierd-neovim-format-on-save&#x2F;#installing-and-starting-prettierd&quot;&gt;Installing and starting prettierd&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;prettierd-neovim-format-on-save&#x2F;#integrating-neovim-with-prettierd&quot;&gt;Integrating Neovim with prettierd&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;prettierd-neovim-format-on-save&#x2F;#not-just-typescript-and-javascript&quot;&gt;Not just TypeScript and JavaScript&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;prettierd-neovim-format-on-save&#x2F;#bonus-using-it-on-the-command-line-with-prettierme&quot;&gt;Bonus: using it on the command line with prettierme&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.fsouza.dev&#x2F;prettierd-neovim-format-on-save&#x2F;#feedback&quot;&gt;Feedback&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;Back in June of 2020, when I was migrating my Neovim configuration to Lua and
to the native LSP client available in neovim 0.5.0, my main language at work
was TypeScript and we used &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;prettier.io&quot;&gt;prettier&lt;&#x2F;a&gt; to keep our code
formatted, and I had it configured to format-on-save with
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;neoclide&#x2F;coc-prettier&quot;&gt;coc-prettier&lt;&#x2F;a&gt;. One of the first
issues I ran into was performance: saving files became deadly slow, to the
point where I gave up and disabled format-on-save.&lt;&#x2F;p&gt;
&lt;p&gt;The thing is: prettier is known to be a fast code formatter, and I didn&#x27;t have
the issue before, so what&#x27;s the  problem here? Is Neovim making prettier
slower? Is coc-prettier doing some magic shit?&lt;&#x2F;p&gt;
&lt;p&gt;Before we start looking into this, let&#x27;s see how prettier behaves when
formatting a somewhat large TypeScript file:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;％ wc -l sample.ts
     586 sample.ts
％ time npx prettier -w sample.ts
sample.ts 332ms
        0.85 real         0.91 user         0.11 sys
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s interesting that prettier reports that it took 332ms to format the file,
but &lt;code&gt;time&lt;&#x2F;code&gt; reports that the whole process took 850ms. Who&#x27;s lying?&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take a look at multiple files:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;％ wc -l sample*.ts
     330 sample1.ts
     718 sample2.ts
     655 sample3.ts
    2511 sample4.ts
     601 sample5.ts
    4815 total
％ time npx prettier -w sample1.ts
sample1.ts 290ms
        0.93 real         0.88 user         0.11 sys
％ time npx prettier -w sample2.ts
sample2.ts 358ms
        1.02 real         1.04 user         0.12 sys
％ time npx prettier -w sample3.ts
sample3.ts 330ms
        0.97 real         0.95 user         0.13 sys
％ time npx prettier -w sample4.ts
sample4.ts 648ms
        1.27 real         1.48 user         0.13 sys
％ time npx prettier -w sample5.ts
sample5.ts 375ms
        1.00 real         1.00 user         0.12 sys
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Notice how formatting &lt;code&gt;sample2.ts&lt;&#x2F;code&gt; and &lt;code&gt;sample4.ts&lt;&#x2F;code&gt; takes more than 1 second in
total! Also interesting is the fact that even though &lt;code&gt;sample1.ts&lt;&#x2F;code&gt; is less the
half the size of &lt;code&gt;sample2.ts&lt;&#x2F;code&gt;, formatting &lt;code&gt;sample2.ts&lt;&#x2F;code&gt; does not take twice as
much time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;who-cares&quot;&gt;Who cares?!&lt;&#x2F;h2&gt;
&lt;p&gt;OK, let&#x27;s take a step back and reflect: who cares if prettier is slow to format
my files? I could run it on a git hook or something like that and not even
notice.&lt;&#x2F;p&gt;
&lt;p&gt;As I mentioned before, I was running format-on-save in Neovim, with a simple
setup, not very fancy:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vimscript&quot; class=&quot;language-vimscript &quot;&gt;&lt;code class=&quot;language-vimscript&quot; data-lang=&quot;vimscript&quot;&gt;autocmd BufWritePre *.ts execute &amp;quot;silent %!npx prettier --stdin-filepath &amp;#x27;&amp;quot; . expand(&amp;#x27;%:p&amp;#x27;) . &amp;quot;&amp;#x27;&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;dotfiles&#x2F;blob&#x2F;0b6d3daaa844796f916b3f056a66af0e25a76c3c&#x2F;autoload&#x2F;fsouza&#x2F;prettier.vim#L19-L30&quot;&gt;(it was a bit fancier than that, but not by much)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So, imagine you&#x27;re using Neovim and every time you save the file you have to
wait 1 second. You&#x27;d be mad, right?! There must be a better way...&lt;&#x2F;p&gt;
&lt;h2 id=&quot;my-visual-studio-code-doesn-t-take-a-second-to-format-on-save-your-vim-is-trash&quot;&gt;&amp;quot;My Visual Studio Code doesn&#x27;t take a second to format-on-save, your Vim is trash&amp;quot;&lt;&#x2F;h2&gt;
&lt;p&gt;To be fair, coc-prettier was pretty fast too. How is that even possible?&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s go back to our sample files, but this time let&#x27;s see what prettier does
if we pass all 5 files to it instead of invoking it 5 times:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;％ time npx prettier -w *.ts
sample1.ts 248ms
sample2.ts 205ms
sample3.ts 110ms
sample4.ts 327ms
sample5.ts 79ms
        1.61 real         2.09 user         0.15 sys
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This time &lt;code&gt;sample2.ts&lt;&#x2F;code&gt; is faster than &lt;code&gt;sample1.ts&lt;&#x2F;code&gt;, even though it&#x27;s twice as
large! What&#x27;s going on? Turns out &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;prettier&#x2F;prettier&#x2F;issues&#x2F;3386&quot;&gt;prettier is slow to
start&lt;&#x2F;a&gt;, both because of
overhead introduced by node.js and prettier itself (it has tons of plugins and
dependencies).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;And how is it fast to format-on-save using VSCode&#x2F;coc-prettier?&lt;&#x2F;strong&gt; Simple:
both coc-prettier and Visual Studio Code are long-running node.js processes,
which host prettier as a library, therefore paying the initialization cost
once.&lt;&#x2F;p&gt;
&lt;p&gt;The solution is simple: we need a long-running node.js process! If you read
through the issue about slow startups in prettier, someone suggests using
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;josephfrazier&#x2F;prettier_d&quot;&gt;prettier_d&lt;&#x2F;a&gt;, but after looking at
how large that project was, I was a bit scared.&lt;&#x2F;p&gt;
&lt;p&gt;Doing some more research, I found
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mantoni&#x2F;eslint_d.js&#x2F;&quot;&gt;eslint_d.js&lt;&#x2F;a&gt;, which solves a similar
issue for eslint, by introducing a daemon which supports binding on a TCP
socket! And the author of eslint_d.js extracted its core functionality in a
library called &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mantoni&#x2F;core_d.js&quot;&gt;core_d.js&lt;&#x2F;a&gt;. So I figured
I could combine that library with prettier and make
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;prettierd&quot;&gt;prettierd&lt;&#x2F;a&gt;, a TCP-enabled daemon for
formatting code using prettier!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;installing-and-starting-prettierd&quot;&gt;Installing and starting prettierd&lt;&#x2F;h2&gt;
&lt;p&gt;The code for prettierd is pretty boring, as it is basically a tiny wrapper
around core_d to invoke the proper prettier functions whenever the server
receives a &amp;quot;request&amp;quot;. The two important things to know about are:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;You can install it with npm and start it with &lt;code&gt;prettierd start&lt;&#x2F;code&gt;:&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;％ npm install -g @fsouza&amp;#x2F;prettierd
％ prettierd start
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alternatively you can do both things with &lt;code&gt;npx&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;％ npx -p @fsouza&amp;#x2F;prettierd prettierd start
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;When it starts, prettierd writes a file with its port number and token&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;％ cat ~&amp;#x2F;.prettierd
53561 cb2ad753df0aca85
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This means that prettierd is running on port 53561 and we can use the token
&lt;code&gt;cb2ad753df0aca85&lt;&#x2F;code&gt; in our requests to format our source code.&lt;&#x2F;p&gt;
&lt;p&gt;core_d&#x27;s protocol is pretty simple:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;token&amp;gt; &amp;lt;working-dir&amp;gt; &amp;lt;file-name&amp;gt;\n
&amp;lt;file-content&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example, we can use netcat:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;％ echo &amp;quot;cb2ad753df0aca85 $PWD sample2.ts&amp;quot; | cat - sample2.ts | &amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;time nc localhost 53561 &amp;gt;sample2-formatted.ts
        0.14 real         0.00 user         0.00 sys
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Remember how formatting &lt;code&gt;sample2.ts&lt;&#x2F;code&gt; took over 1 second? Not anymore. :)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;integrating-neovim-with-prettierd&quot;&gt;Integrating Neovim with prettierd&lt;&#x2F;h2&gt;
&lt;p&gt;Using netcat is great and we could probably write a shell script that we could
use in our (fun fact: someone else did this, check the bonus section!), but
Neovim is powerful enough to connect directly to the TCP server.&lt;&#x2F;p&gt;
&lt;p&gt;How? Neovim has an event loop, which is implemented using
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;libuv.org&quot;&gt;libuv&lt;&#x2F;a&gt;. libuv is probably the best event loop there in the
wild, but don&#x27;t quote me :) Besides shipping the event loop and all the libuv
code, Neovim also bundles &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;luvit&#x2F;luv&quot;&gt;luv&lt;&#x2F;a&gt; and expose the
loop as a Lua API, so we can use &lt;code&gt;vim.loop.&amp;lt;nice-async-things&amp;gt;&lt;&#x2F;code&gt;! Taylor
Thompson has written an amazing post about the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;teukka.tech&#x2F;vimloop.html&quot;&gt;using libuv in
Neovim&lt;&#x2F;a&gt;, go check it out if you&#x27;re curious :)&lt;&#x2F;p&gt;
&lt;p&gt;Among the utilities provided by libuv, there&#x27;s a tcp module which includes both
a TCP client and a TCP server! In our case we want to use a client, so we
invoke the &lt;code&gt;tcp_connect&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lua&quot; class=&quot;language-lua &quot;&gt;&lt;code class=&quot;language-lua&quot; data-lang=&quot;lua&quot;&gt;local callback = ...
local port = 53561
local token = &amp;#x27;cb2ad753df0aca85&amp;#x27;
local client = vim.loop.new_tcp()
vim.loop.tcp_connect(client, &amp;#x27;127.0.0.1&amp;#x27;, port, callback)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since this is async world, we need to pass a callback that gets executed
whenever the connection happens (or in case something goes wrong). So the first
thing we do in our callback is check for errors, which looks familiar for Go
developers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lua&quot; class=&quot;language-lua &quot;&gt;&lt;code class=&quot;language-lua&quot; data-lang=&quot;lua&quot;&gt;local callback = function(err)
  if err then
    error(err)
  end

  ...
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If there are no errors, it means we can send the contents of our file to the
remote server. We have the port and the token, but we also need the contents of
the buffer. So let&#x27;s grab the contents of the current buffer and send that to
the server, then read back the response and write it back to the buffer! This
time I&#x27;ll include the entire implementation of the callback, with some inline
comments:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lua&quot; class=&quot;language-lua &quot;&gt;&lt;code class=&quot;language-lua&quot; data-lang=&quot;lua&quot;&gt;local callback = function(err)
  if err then
    error(err)
  end

  -- grab the contents of the buffer and add first row to match core_d&amp;#x27;s protocol
  local bufnr = vim.api.nvim_get_current_buf()
  local first_line = string.format(&amp;#x27;%s %s %s&amp;#x27;, token, vim.loop.cwd(), &amp;#x27;sample2.js&amp;#x27;)
  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, true)
  table.insert(lines, 1, first_line)

  -- start reading the response
  local response = &amp;#x27;&amp;#x27;
  vim.loop.read_start(client, function(read_err, chunk)
    -- check if there was any error reading data back, if so, close the
    -- connection and report the error.
    if read_err then
      vim.loop.close(client)
      error(&amp;#x27;failed to read data from prettierd: &amp;#x27; .. read_err)
    end

    -- libuv will call this callback with no data and no error when it&amp;#x27;s done,
    -- so if there&amp;#x27;s data, concatenate it into the final response. Otherwise it
    -- means we&amp;#x27;re done, so invoke the `write_to_buf` to write the data back.
    if chunk then
      response = response .. chunk
    else
      vim.loop.close(client)
      write_to_buf(response, bufnr)
    end
  end)

  -- write the request
  vim.loop.write(client, table.concat(lines, &amp;#x27;\n&amp;#x27;))

  -- signal to the server that we&amp;#x27;re done writing the request
  vim.loop.shutdown(client)
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And here&#x27;s a simple implementation of &lt;code&gt;write_to_buf&lt;&#x2F;code&gt;. The trickiest bit is
error handling: the way errors are reported isn&#x27;t great, but it&#x27;s acceptable:
if prettier fails, the last line contains a message in the format &lt;code&gt;# exit &amp;lt;code&amp;gt; ...&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lua&quot; class=&quot;language-lua &quot;&gt;&lt;code class=&quot;language-lua&quot; data-lang=&quot;lua&quot;&gt;local function write_to_buf(data, bufnr)
  local new_lines = vim.split(data, &amp;#x27;\n&amp;#x27;)

  -- check for errors
  if string.find(new_lines[#new_lines], &amp;#x27;^# exit %d+&amp;#x27;) then
    error(string.format(&amp;#x27;failed to format with prettier: %s&amp;#x27;, data))
  end

  -- write contents
  vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, new_lines)
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now you can throw all of that in a &lt;code&gt;format()&lt;&#x2F;code&gt; function and invoke it on write!&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; the code here is a simplified version of what I actually use. For
the actual config, including automatic process management, retries, error
handling and cursor positioning, checkout
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;dotfiles&#x2F;blob&#x2F;20aa0be6d06224224a50d24c5b63929f16cdb7da&#x2F;nvim&#x2F;lua&#x2F;fsouza&#x2F;plugin&#x2F;prettierd.lua#L56&quot;&gt;prettierd.lua&lt;&#x2F;a&gt;
in my dotfiles repo.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;not-just-typescript-and-javascript&quot;&gt;Not just TypeScript and JavaScript&lt;&#x2F;h2&gt;
&lt;p&gt;Users of prettier are aware of this, but prettier is not just about JavaScript
and TypeScript, it can be used with many other file formats, including HTML,
Markdown, CSS, YAML, JSON and others. Check the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;prettier.io&#x2F;docs&#x2F;en&#x2F;options.html#parser&quot;&gt;parser configuration in
prettier docs&lt;&#x2F;a&gt; for a full
list, and keep in mind that additional file types can be added via plugins!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bonus-using-it-on-the-command-line-with-prettierme&quot;&gt;Bonus: using it on the command line with prettierme&lt;&#x2F;h2&gt;
&lt;p&gt;If you want to use Vim instead of Neovim, or don&#x27;t want to maintain a TCP
client in your editor configuration, you can leverage &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ruyadorno&#x2F;prettierme&quot;&gt;Ruy Adorno&#x27;s
prettierme&lt;&#x2F;a&gt; to use a command line
interface that is more similar to the standard prettier interface. prettierme
is basically a wrapper around our &lt;code&gt;netcat&lt;&#x2F;code&gt; example.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;feedback&quot;&gt;Feedback&lt;&#x2F;h2&gt;
&lt;p&gt;Do you have any feedback? Questions? Concerns? Wanna fix a typo? Checkout the
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;blog&#x2F;blob&#x2F;HEAD&#x2F;content&#x2F;2021-02-12-prettierd-neovim-format-on-save&#x2F;index.md&quot;&gt;source for this post in
GitHub&lt;&#x2F;a&gt;
(feel free to send a PR), or the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;blog&#x2F;discussions&#x2F;14&quot;&gt;discussion in the GitHub
repo&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Using Juju to orchestrate CentOS-based cloud services</title>
		<published>2012-07-28T00:00:00+00:00</published>
		<updated>2012-07-28T00:00:00+00:00</updated>
		<link href="https://blog.fsouza.dev/using-juju-to-orchestrate-centos-based/" type="text/html"/>
		<id>https://blog.fsouza.dev/using-juju-to-orchestrate-centos-based/</id>
		<content type="html">&lt;p&gt;Earlier this week I had the opportunity to meet &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;kylemacdonald&#x2F;&quot;&gt;Kyle
MacDonald&lt;&#x2F;a&gt;, head of &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;cloud.ubuntu.com&#x2F;&quot;&gt;Ubuntu
Cloud&lt;&#x2F;a&gt;, during &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;fisl.org.br&#x2F;13&quot;&gt;FISL&lt;&#x2F;a&gt;, and he
was surprised when we told him we are &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lists.ubuntu.com&#x2F;archives&#x2F;juju-dev&#x2F;2012-June&#x2F;000001.html&quot;&gt;using Juju with
CentOS&lt;&#x2F;a&gt; at
Globo.com. Then I decided to write this post explaining how we came up with a
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;globocom&#x2F;juju-centos-6&quot;&gt;patched version of Juju&lt;&#x2F;a&gt; that
allows us to have CentOS clouds managed by Juju.&lt;a name=&quot;more&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For those who doesn&#x27;t know Juju, it&#x27;s a service orchestration tool, focused on
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DevOps&quot;&gt;devops&lt;&#x2F;a&gt; &amp;quot;development method&amp;quot;. It allows
you to deploy services on clouds, local machine and even bare metal machines
(using Canonical&#x27;s MAAS).&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s based on &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;juju.ubuntu.com&#x2F;docs&#x2F;charm-store.html&quot;&gt;charms&lt;&#x2F;a&gt; and very
straightforward to use. Here is a very basic set of commands with which you can
deploy a Wordpress related to a MySQL service:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;% juju bootstrap
% juju deploy mysql
% juju deploy wordpress
% juju add-relation wordpress mysql
% juju expose wordpress
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These commands will boostrap the environment, setting up a bootstrap machine
which will manage your services; deploy mysql and wordpress instances; add a
relation between them; and expose the wordpress port. The voilà, we have a
wordpress deployed, and ready to serve our posts. Amazing, huh?&lt;&#x2F;p&gt;
&lt;p&gt;But there is an issue: although you can install the &lt;code&gt;juju&lt;&#x2F;code&gt; command line tool in
almost any OS (including Mac OS), right now you are able do deploy only
Ubuntu-based services (you must use an Ubuntu instance or container).&lt;&#x2F;p&gt;
&lt;p&gt;To change this behavior, and enable Juju to spawn CentOS instances (and
containers, if you have a CentOS lxc template), we need to develop and apply
some changes to Juju and
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;help.ubuntu.com&#x2F;community&#x2F;CloudInit&quot;&gt;cloud-init&lt;&#x2F;a&gt;. Juju uses cloud-init
to spawn machines with proper dependencies set up, and it&#x27;s based on modules.
All we need to do, is add a module able to install rpm packages using &lt;code&gt;yum&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;cloud-init&lt;&#x2F;code&gt; modules are Python modules that starts with &lt;code&gt;cc_&lt;&#x2F;code&gt; and implement a
&lt;code&gt;handle&lt;&#x2F;code&gt; function (for example, a module called &amp;quot;yum_packages&amp;quot; would be written
to a file called &lt;code&gt;cc_yum_packages.py&lt;&#x2F;code&gt;). So, here is the code for the module
&lt;code&gt;yum_packages&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import subprocess
import traceback

from cloudinit import CloudConfig, util

frequency = CloudConfig.per_instance

def yum_install(packages):
    cmd = [&amp;quot;yum&amp;quot;, &amp;quot;--quiet&amp;quot;, &amp;quot;--assumeyes&amp;quot;, &amp;quot;install&amp;quot;]
    cmd.extend(packages)
    subprocess.check_call(cmd)

def handle(_name, cfg, _cloud, log, args):
    pkglist = util.get_cfg_option_list_or_str(cfg, &amp;quot;packages&amp;quot;, [])

    if pkglist:
        try:
            yum_install(pkglist)
        except subprocess.CalledProcessError:
            log.warn(&amp;quot;Failed to install yum packages: %s&amp;quot; % pkglist)
            log.debug(traceback.format_exc())
            raise

    return True
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The module installs all packages listed in cloud-init yaml file. If we want to install &lt;code&gt;emacs-nox&lt;&#x2F;code&gt; package, we would write this yaml file and use it as user data in the instance:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#cloud-config
modules:
 - yum_packages
packages: [emacs-nox]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;cloud-init&lt;&#x2F;code&gt; already works on Fedora, with Python 2.7, but to work on CentOS 6, with Python 2.6, it needs a patch:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;--- cloudinit&amp;#x2F;util.py 2012-05-22 12:18:21.000000000 -0300
+++ cloudinit&amp;#x2F;util.py 2012-05-31 12:44:24.000000000 -0300
@@ -227,7 +227,7 @@
         stderr=subprocess.PIPE, stdin=subprocess.PIPE)
     out, err = sp.communicate(input_)
     if sp.returncode is not 0:
-        raise subprocess.CalledProcessError(sp.returncode, args, (out, err))
+        raise subprocess.CalledProcessError(sp.returncode, args)
     return(out, err)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;ve packet up this module and this patch in a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;globocom&#x2F;cloudinit-centos-6&quot;&gt;RPM
package&lt;&#x2F;a&gt; that must be
pre-installed in the lxc template and AMI images. Now, we need to change Juju
in order to make it use the &lt;code&gt;yum_packages&lt;&#x2F;code&gt; module, and include all RPM packages
that we need to install when the machine borns.&lt;&#x2F;p&gt;
&lt;p&gt;Is Juju, there is a class that is responsible for building and rendering the
YAML file used by cloud-init. We can extend it and change only two methods:
&lt;code&gt;_collect_packages&lt;&#x2F;code&gt;, that returns the list of packages that will be installed
in the machine after it is spawned; and &lt;code&gt;render&lt;&#x2F;code&gt; that returns the file itself.
Here is our &lt;code&gt;CentOSCloudInit&lt;&#x2F;code&gt; class (within the patch):&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;diff -u juju-0.5-bzr531.orig&amp;#x2F;juju&amp;#x2F;providers&amp;#x2F;common&amp;#x2F;cloudinit.py juju-0.5-bzr531&amp;#x2F;juju&amp;#x2F;providers&amp;#x2F;common&amp;#x2F;cloudinit.py
--- juju-0.5-bzr531.orig&amp;#x2F;juju&amp;#x2F;providers&amp;#x2F;common&amp;#x2F;cloudinit.py 2012-05-31 15:42:17.480769486 -0300
+++ juju-0.5-bzr531&amp;#x2F;juju&amp;#x2F;providers&amp;#x2F;common&amp;#x2F;cloudinit.py 2012-05-31 15:55:13.342884919 -0300
@@ -324,3 +324,32 @@
             &amp;quot;machine-id&amp;quot;: self._machine_id,
             &amp;quot;juju-provider-type&amp;quot;: self._provider_type,
             &amp;quot;juju-zookeeper-hosts&amp;quot;: self._join_zookeeper_hosts()}
+
+
+class CentOSCloudInit(CloudInit):
+
+    def _collect_packages(self):
+        packages = [
+            &amp;quot;bzr&amp;quot;, &amp;quot;byobu&amp;quot;, &amp;quot;tmux&amp;quot;, &amp;quot;python-setuptools&amp;quot;, &amp;quot;python-twisted&amp;quot;,
+            &amp;quot;python-txaws&amp;quot;, &amp;quot;python-zookeeper&amp;quot;, &amp;quot;python-devel&amp;quot;, &amp;quot;juju&amp;quot;]
+        if self._zookeeper:
+            packages.extend([
+                &amp;quot;zookeeper&amp;quot;, &amp;quot;libzookeeper&amp;quot;, &amp;quot;libzookeeper-devel&amp;quot;])
+        return packages
+
+    def render(self):
+        &amp;quot;&amp;quot;&amp;quot;Get content for a cloud-init file with appropriate specifications.
+
+        :rtype: str
+
+        :raises: :exc:`juju.errors.CloudInitError` if there isn&amp;#x27;t enough
+            information to create a useful cloud-init.
+        &amp;quot;&amp;quot;&amp;quot;
+        self._validate()
+        return format_cloud_init(
+            self._ssh_keys,
+            packages=self._collect_packages(),
+            repositories=self._collect_repositories(),
+            scripts=self._collect_scripts(),
+            data=self._collect_machine_data(),
+            modules=[&amp;quot;ssh&amp;quot;, &amp;quot;yum_packages&amp;quot;, &amp;quot;runcmd&amp;quot;])
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The other change we need is in the &lt;code&gt;format_cloud_init&lt;&#x2F;code&gt; function, in order to
make it recognize the &lt;code&gt;modules&lt;&#x2F;code&gt; parameter that we used above, and tell
cloud-init to not run &lt;code&gt;apt-get&lt;&#x2F;code&gt; (update nor upgrade). Here is the patch:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;diff -ur juju-0.5-bzr531.orig&amp;#x2F;juju&amp;#x2F;providers&amp;#x2F;common&amp;#x2F;utils.py juju-0.5-bzr531&amp;#x2F;juju&amp;#x2F;providers&amp;#x2F;common&amp;#x2F;utils.py
--- juju-0.5-bzr531.orig&amp;#x2F;juju&amp;#x2F;providers&amp;#x2F;common&amp;#x2F;utils.py 2012-05-31 15:42:17.480769486 -0300
+++ juju-0.5-bzr531&amp;#x2F;juju&amp;#x2F;providers&amp;#x2F;common&amp;#x2F;utils.py 2012-05-31 15:44:06.605014021 -0300
@@ -85,7 +85,7 @@

 def format_cloud_init(
-    authorized_keys, packages=(), repositories=None, scripts=None, data=None):
+    authorized_keys, packages=(), repositories=None, scripts=None, data=None, modules=None):
     &amp;quot;&amp;quot;&amp;quot;Format a user-data cloud-init file.

     This will enable package installation, and ssh access, and script
@@ -117,8 +117,8 @@
         structure.
     &amp;quot;&amp;quot;&amp;quot;
     cloud_config = {
-        &amp;quot;apt-update&amp;quot;: True,
-        &amp;quot;apt-upgrade&amp;quot;: True,
+        &amp;quot;apt-update&amp;quot;: False,
+        &amp;quot;apt-upgrade&amp;quot;: False,
         &amp;quot;ssh_authorized_keys&amp;quot;: authorized_keys,
         &amp;quot;packages&amp;quot;: [],
         &amp;quot;output&amp;quot;: {&amp;quot;all&amp;quot;: &amp;quot;| tee -a &amp;#x2F;var&amp;#x2F;log&amp;#x2F;cloud-init-output.log&amp;quot;}}
@@ -136,6 +136,11 @@
     if scripts:
         cloud_config[&amp;quot;runcmd&amp;quot;] = scripts

+    if modules:
+        cloud_config[&amp;quot;modules&amp;quot;] = modules
+
     output = safe_dump(cloud_config)
     output = &amp;quot;#cloud-config\n%s&amp;quot; % (output)
     return output
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This patch is also packed up within
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;globocom&#x2F;juju-centos-6&quot;&gt;juju-centos-6&lt;&#x2F;a&gt; repository, which
provides sources for building RPM packages for juju, and also some pre-built
RPM packages.&lt;&#x2F;p&gt;
&lt;p&gt;Now just build an AMI image with &lt;code&gt;cloudinit&lt;&#x2F;code&gt; pre-installed, configure your juju
&lt;code&gt;environments.yaml&lt;&#x2F;code&gt; file to use this image in the environment and you are ready
to deploy cloud services on CentOS machines using Juju!&lt;&#x2F;p&gt;
&lt;p&gt;Some caveats:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Juju needs a user called &lt;code&gt;ubuntu&lt;&#x2F;code&gt; to interact with its machines, so you will
need to create this user in your CentOS AMI&#x2F;template.&lt;&#x2F;li&gt;
&lt;li&gt;You need to host all RPM packages for
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;globocom&#x2F;juju-centos-6&quot;&gt;juju&lt;&#x2F;a&gt;,
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;globocom&#x2F;cloudinit-centos-6&quot;&gt;cloud-init&lt;&#x2F;a&gt; and following
dependencies in some &lt;code&gt;yum&lt;&#x2F;code&gt; repository (I haven&#x27;t submitted them to any public
repository):
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;globocom&#x2F;python-txaws-centos-6&quot;&gt;python-txaws&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;globocom&#x2F;python-txzookeeper-centos-6&quot;&gt;python-txzookeeper&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;globocom&#x2F;zookeeper-centos-6&quot;&gt;zookeeper&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;With this patched Juju, you will have a pure-centos cloud. It does not enable
you to have multiple OSes in the same environment.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;It&#x27;s important to notice that we are going to put some effort to make the Go
version of juju born supporting multiple OSes, ideally through an interface
that makes it extensible to any other OS, not Ubuntu and CentOS only.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Setting up a Django production environment: compiling and configuring nginx</title>
		<published>2011-11-06T00:00:00+00:00</published>
		<updated>2011-11-06T00:00:00+00:00</updated>
		<link href="https://blog.fsouza.dev/setting-up-django-production/" type="text/html"/>
		<id>https://blog.fsouza.dev/setting-up-django-production/</id>
		<content type="html">&lt;p&gt;Here is another series of posts: now I’m going to write about setting up a
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;djangoproject.com&quot;&gt;Django&lt;&#x2F;a&gt; production environment using
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nginx.org&quot;&gt;nginx&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;gunicorn.org&quot;&gt;Green Unicorn&lt;&#x2F;a&gt; in a
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;virtualenv.org&quot;&gt;virtual environment&lt;&#x2F;a&gt;. The subject in this first post is
nginx, which is my favorite web server.&lt;&#x2F;p&gt;
&lt;p&gt;This post explains how to install nginx from sources, compiling it (on Linux).
You might want to use &lt;code&gt;apt&lt;&#x2F;code&gt;, &lt;code&gt;zif&lt;&#x2F;code&gt;, &lt;code&gt;yum&lt;&#x2F;code&gt; or &lt;code&gt;ports&lt;&#x2F;code&gt;, but I prefer building
from sources. So, to build from sources, make sure you have all development
dependencies (C headers, including the PCRE library headers, nginx rewrite
module uses it). If you want to build nginx with SSL support, keep in mind that
you will need the libssl headers too.&lt;&#x2F;p&gt;
&lt;p&gt;Build nginx from source is a straightforward process: all you need to do is
download it from the official site and build with some simple options. In our
setup, we’re going to install nginx under &lt;code&gt;&#x2F;opt&#x2F;nginx&lt;&#x2F;code&gt;, and use it with the
nginx system user. So, let’s download and extract the latest stable version
(1.0.9) from nginx website:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;% curl -O http:&amp;#x2F;&amp;#x2F;nginx.org&amp;#x2F;download&amp;#x2F;nginx-1.0.9.tar.gz
% tar -xzf nginx-1.0.9.tar.gz
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once you have extracted it, just configure, compile and install:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;% .&amp;#x2F;configure --prefix=&amp;#x2F;opt&amp;#x2F;nginx --user=nginx --group=nginx
% make
% [sudo] make install
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, we provided the &lt;code&gt;&#x2F;opt&#x2F;nginx&lt;&#x2F;code&gt; to configure, make sure the &lt;code&gt;&#x2F;opt&lt;&#x2F;code&gt;
directory exists. Also, make sure that there is a user and a group called
&lt;em&gt;nginx&lt;&#x2F;em&gt;, if they don’t exist, add them:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;% [sudo] adduser --system --no-create-home --disabled-login --disabled-password --group nginx
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After that, you can start nginx using the command line below:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;% [sudo] &amp;#x2F;opt&amp;#x2F;nginx&amp;#x2F;sbin&amp;#x2F;nginx
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Linode provides an &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;library.linode.com&#x2F;assets&#x2F;634-init-deb.sh&quot;&gt;init
script&lt;&#x2F;a&gt; that uses
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;man.he.net&#x2F;man8&#x2F;start-stop-daemon&quot;&gt;start-stop-daemon&lt;&#x2F;a&gt;, you might want
to use it.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;nginx-configuration&quot;&gt;nginx configuration&lt;&#x2F;h4&gt;
&lt;p&gt;nginx comes with a default &lt;code&gt;nginx.conf&lt;&#x2F;code&gt; file, let’s change it to reflect the
following configuration requirements:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;nginx should start workers with the &lt;code&gt;nginx&lt;&#x2F;code&gt; user&lt;&#x2F;li&gt;
&lt;li&gt;nginx should have two worker processes&lt;&#x2F;li&gt;
&lt;li&gt;the PID should be stored in the &lt;code&gt;&#x2F;opt&#x2F;nginx&#x2F;log&#x2F;nginx.pid&lt;&#x2F;code&gt; file&lt;&#x2F;li&gt;
&lt;li&gt;nginx must have an access log in &lt;code&gt;&#x2F;opt&#x2F;nginx&#x2F;logs&#x2F;access.log&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the configuration for the Django project we’re going to develop should be
versioned with the entire code, so it must be included in the &lt;code&gt;nginx.conf&lt;&#x2F;code&gt;
file (assume that the &lt;code&gt;library&lt;&#x2F;code&gt; project is in the directory &lt;code&gt;&#x2F;opt&#x2F;projects&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So here is the &lt;code&gt;nginx.conf&lt;&#x2F;code&gt; for the requirements above:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;user  nginx;
worker_processes  2;

pid logs&amp;#x2F;nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application&amp;#x2F;octet-stream;

    log_format  main  &amp;#x27;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &amp;#x27;
                     &amp;#x27;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &amp;#x27;
                     &amp;#x27;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&amp;#x27;;

    access_log  logs&amp;#x2F;access.log  main;

    sendfile           on;
    keepalive_timeout  65;

    include &amp;#x2F;opt&amp;#x2F;projects&amp;#x2F;showcase&amp;#x2F;nginx.conf;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we just need to write the configuration for our Django project. I’m using
an old sample project written while I was working at
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.giran.com.br&quot;&gt;Giran&lt;&#x2F;a&gt;: the name is &lt;em&gt;lojas giranianas&lt;&#x2F;em&gt;, a nonsense
portuguese joke with a famous brazilian store. It’s an unfinished showcase of
products, it’s like an e-commerce project, but it can’t sell, so it’s just a
product catalog. The code is available at
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;fast-track-django&quot;&gt;Github&lt;&#x2F;a&gt;. The &lt;code&gt;nginx.conf&lt;&#x2F;code&gt; file
for the repository is here:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen 80;
    server_name localhost;

    charset utf-8;

    location &amp;#x2F; {
        proxy_set_header    X-Real-IP   $remote_addr;
        proxy_set_header    Host        $http_host;
        proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

        proxy_pass http:&amp;#x2F;&amp;#x2F;localhost:8000;
    }

    location &amp;#x2F;static {
        root &amp;#x2F;opt&amp;#x2F;projects&amp;#x2F;showcase&amp;#x2F;;
        expires 1d;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The server listens on port &lt;code&gt;80&lt;&#x2F;code&gt;, responds for the &lt;code&gt;localhost&lt;&#x2F;code&gt; hostname (&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.w3.org&#x2F;Protocols&#x2F;rfc2616&#x2F;rfc2616-sec14.html&quot;&gt;read
more about the Host
header&lt;&#x2F;a&gt;). The
&lt;code&gt;location &#x2F;static&lt;&#x2F;code&gt; directive says that nginx will serve the static files of the
project. It also includes an &lt;code&gt;expires&lt;&#x2F;code&gt; directive for caching control. The
&lt;code&gt;location &#x2F;&lt;&#x2F;code&gt; directive makes a &lt;code&gt;proxy_pass&lt;&#x2F;code&gt;, forwarding all requisitions to an
upstream server listening on port 8000, this server is the subject of the next
post of the series: the Green Unicorn (gunicorn) server.&lt;&#x2F;p&gt;
&lt;p&gt;Not only the HTTP request itself is forwarded to the gunicorn server, but also
some headers, that helps to properly deal with the request:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;X-Real-IP:&lt;&#x2F;strong&gt; forwards the remote address to the upstream server, so it can
know the real IP of the user. When nginx forwards the request to gunicorn,
without this header, all gunicorn will know is that there is a request coming
from localhost (or wherever the nginx server is), the remote address is
always the IP address of the machine where nginx is running (who actually
make the request to gunicorn)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Host:&lt;&#x2F;strong&gt; the &lt;code&gt;Host&lt;&#x2F;code&gt; header is forwarded so gunicorn can treat different
requests for different hosts. Without this header, it will be impossible to
Gunicorn to have these constraints&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;X-Forwarded-For:&lt;&#x2F;strong&gt; also known as XFF, this header provide more precise
information about the real IP who makes the request. Imagine there are 10
proxies between the user machine and your webserver, the XFF header will all
these proxies comma separated. In order to not turn a proxy into an
anonymizer, it’s a good practice to always forward this header.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So that is it, in the next post we are going to install and run gunicorn. In
other posts, we’ll see how to make automated deploys using
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;fabfile.org&quot;&gt;Fabric&lt;&#x2F;a&gt;, and some tricks on caching (using the
&lt;code&gt;proxy_cache&lt;&#x2F;code&gt; directive and integrating Django, nginx and
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;memcached.org&quot;&gt;memcached&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;See you in next posts.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Go solution for the Dining philosophers problem</title>
		<published>2011-10-30T00:00:00+00:00</published>
		<updated>2011-10-30T00:00:00+00:00</updated>
		<link href="https://blog.fsouza.dev/go-solution-for-dining-philosophers/" type="text/html"/>
		<id>https://blog.fsouza.dev/go-solution-for-dining-philosophers/</id>
		<content type="html">&lt;p&gt;I spent part of the Sunday solving the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dining_philosophers_problem&quot;&gt;Dining
Philosophers&lt;&#x2F;a&gt; using
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;golang.org&#x2F;&quot;&gt;Go&lt;&#x2F;a&gt;. The given solution is based in the description for
the problem present in &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;greenteapress.com&#x2F;semaphores&#x2F;&quot;&gt;The Little Book of
Semaphores&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Dining Philosophers Problem was proposed by Dijkstra in 1965, when
dinosaurs ruled the earth. It appears in a number of variations, but the
standard features are a table with ﬁve plates, ﬁve forks (or chopsticks) and a
big bowl of spaghetti.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;There are some constraints:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Only one philosopher can hold a fork at a time&lt;&#x2F;li&gt;
&lt;li&gt;It must be impossible for a deadlock to occur&lt;&#x2F;li&gt;
&lt;li&gt;It must be impossible for a philosopher to starve waiting for a fork&lt;&#x2F;li&gt;
&lt;li&gt;It must be possible for more than one philosopher to eat at the same time&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;No more talk, here is my solution for the problem:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

type Fork struct {
	sync.Mutex
}

type Table struct {
	philosophers chan Philosopher
	forks []*Fork
}

func NewTable(forks int) *Table {
	t := new(Table)
	t.philosophers = make(chan Philosopher, forks - 1)
	t.forks = make([]*Fork, forks)
	for i := 0; i &amp;lt; forks; i++ {
		t.forks[i] = new(Fork)
	}
	return t
}

func (t *Table) PushPhilosopher(p Philosopher) {
	p.table = t
	t.philosophers &amp;lt;- p
}

func (t *Table) PopPhilosopher() Philosopher {
	p := &amp;lt;-t.philosophers
	p.table = nil
	return p
}

func (t *Table) RightFork(philosopherIndex int) *Fork {
	f := t.forks[philosopherIndex]
	return f
}

func (t *Table) LeftFork(philosopherIndex int) *Fork {
	f := t.forks[(philosopherIndex + 1) % len(t.forks)]
	return f
}

type Philosopher struct {
	name string
	index int
	table *Table
	fed chan int
}

func (p Philosopher) Think() {
	fmt.Printf(&amp;quot;%s is thinking...\n&amp;quot;, p.name)
	time.Sleep(3e9)
	p.table.PushPhilosopher(p)
}

func (p Philosopher) Eat() {
	p.GetForks()
	fmt.Printf(&amp;quot;%s is eating...\n&amp;quot;, p.name)
	time.Sleep(3e9)
	p.PutForks()
	p.table.PopPhilosopher()
	p.fed &amp;lt;- 1
}

func (p Philosopher) GetForks() {
	rightFork := p.table.RightFork(p.index)
	rightFork.Lock()

	leftFork := p.table.LeftFork(p.index)
	leftFork.Lock()
}

func (p Philosopher) PutForks() {
	rightFork := p.table.RightFork(p.index)
	rightFork.Unlock()

	leftFork := p.table.LeftFork(p.index)
	leftFork.Unlock()
}

func main() {
	table := NewTable(5)
	philosophers := []Philosopher{
		Philosopher{&amp;quot;Thomas Nagel&amp;quot;, 0, table, make(chan int)},
		Philosopher{&amp;quot;Elizabeth Anscombe&amp;quot;, 1, table, make(chan int)},
		Philosopher{&amp;quot;Martin Heidegger&amp;quot;, 2, table, make(chan int)},
		Philosopher{&amp;quot;Peter Lombard&amp;quot;, 3, table, make(chan int)},
		Philosopher{&amp;quot;Gottfried Leibniz&amp;quot;, 4, table, make(chan int)},
	}

	for {
		for _, p := range philosophers {
			go func(p Philosopher){
				p.Think()
				p.Eat()
			}(p)
		}

		for _, p := range philosophers {
			&amp;lt;-p.fed
			fmt.Printf(&amp;quot;%s was fed.\n&amp;quot;, p.name)
		}
	}

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Testing jQuery plugins with Jasmine</title>
		<published>2011-05-28T00:00:00+00:00</published>
		<updated>2011-05-28T00:00:00+00:00</updated>
		<link href="https://blog.fsouza.dev/testing-jquery-plugins-with-jasmine/" type="text/html"/>
		<id>https://blog.fsouza.dev/testing-jquery-plugins-with-jasmine/</id>
		<content type="html">&lt;p&gt;Since I started working at &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;globo.com&quot;&gt;Globo.com&lt;&#x2F;a&gt;, I developed some
jQuery plugins (for internal use) with my team, and we are starting to test
these plugins using &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;pivotal.github.com&#x2F;jasmine&#x2F;&quot;&gt;Jasmine&lt;&#x2F;a&gt;, &lt;em&gt;“a
behavior-driven development framework for testing your JavaScript code”&lt;&#x2F;em&gt;. In
this post, I will show how to develop a very simple jQuery plugin (based on an
example that I learned with &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;rdworth.org&#x2F;&quot;&gt;Ricard D. Worth&lt;&#x2F;a&gt;): zebrafy.
This plugin “zebrafies” a table, applying different classes to odd and even
lines. Let’s start setting up a Jasmine environment... First step is download
the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;pivotal.github.com&#x2F;jasmine&#x2F;download.html&quot;&gt;standalone version of
Jasmine&lt;&#x2F;a&gt;, then extract it and
edit the runner. The runner is a simple HTML file, that loads Jasmine and all
JavaScript files you want to test. But, wait... why not test using node.js or
something like this? Do I really need the browser on this test? You don’t
&lt;strong&gt;need&lt;&#x2F;strong&gt;, but I think it is important to test a plugin that works with the DOM
using a real browser. Let’s delete some files and lines from &lt;em&gt;SpecRunner.html&lt;&#x2F;em&gt;
file, so we adapt it for our plugin. This is how the structure is going to look
like:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;.
├── SpecRunner.html
├── lib
│   ├── jasmine-1.0.2
│   │   ├── MIT.LICENSE
│   │   ├── jasmine-html.js
│   │   ├── jasmine.css
│   │   └── jasmine.js
│   └── jquery-1.6.1.min.js
├── spec
│   └── ZebrafySpec.js
└── src
    └── jquery.zebrafy.js
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can create the files &lt;code&gt;jquery.zebrafy.js&lt;&#x2F;code&gt; and &lt;code&gt;ZebrafySpec.js&lt;&#x2F;code&gt;, but
remember: it is BDD, we need to describe
the behavior first, then write the code. So let’s start writing the specs in
&lt;code&gt;ZebrafySpec.js&lt;&#x2F;code&gt; file using Jasmine. If you are familiar with
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;rspec.info&quot;&gt;RSpec&lt;&#x2F;a&gt; syntax, it’s easy to understand how to write spec
withs Jasmine, if you aren’t, here is the clue: Jasmine is a lib with some
functions used for writing tests in an easier way. I’m going to explain each
function “on demmand”, when we need something, we learn how to use it! ;)&lt;&#x2F;p&gt;
&lt;p&gt;First of all, we need to start a new test suite. Jasmine provides the
&lt;code&gt;describe&lt;&#x2F;code&gt; function for that, this function receives a string and another
function (a callback). The string describes the test suite and the function is
a callback that delimites the scope of the test suite. Here is the &lt;code&gt;Zebrafy&lt;&#x2F;code&gt;
suite:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;describe(&amp;#x27;Zebrafy&amp;#x27;, function () {

});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s start describing the behavior we want to get from the plugin. The most
basic is: we want different CSS classes for odd an even lines in a table.
Jasmine provides the &lt;code&gt;it&lt;&#x2F;code&gt; function for writing the tests. It also receives a
string and a callback: the string is a description for the test and the
callback is the function executed as test. Here is the very first test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;it(&amp;#x27;should apply classes zebrafy-odd and zebrafy-even to each other table lines&amp;#x27;, function () {
    var table = $(&amp;quot;#zebra-table&amp;quot;);
    table.zebrafy();
    expect(table).toBeZebrafyied();
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Okay, here we go: in the first line of the callback, we are using jQuery to
select a table using the &lt;code&gt;#zebra-table&lt;&#x2F;code&gt; selector, which will look up for a
table with the ID attribute equals to &lt;em&gt;“zebra-table”&lt;&#x2F;em&gt;, but we don’t have this
table in the DOM. What about add a new table to the DOM in a hook executed
before the test run and remove the table in another hook that runs after the
test? Jasmine provide two functions: &lt;code&gt;beforeEach&lt;&#x2F;code&gt; and &lt;code&gt;afterEach&lt;&#x2F;code&gt;. Both
functions receive a callback function to be executed and, as the names suggest,
the &lt;code&gt;beforeEach&lt;&#x2F;code&gt; callback is called before each test run, and the &lt;code&gt;afterEach&lt;&#x2F;code&gt;
callback is called after the test run. Here are the hooks:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;beforeEach(function () {
    $(&amp;#x27;&amp;lt;table id=&amp;quot;zebra-table&amp;quot;&amp;gt;&amp;lt;&amp;#x2F;table&amp;gt;&amp;#x27;).appendTo(&amp;#x27;body&amp;#x27;);
    for (var i=0; i &amp;lt; 10; i++) {
        $(&amp;#x27;&amp;lt;tr&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;&amp;#x27;).append(&amp;#x27;&amp;lt;td&amp;gt;&amp;lt;&amp;#x2F;td&amp;gt;&amp;#x27;).append(&amp;#x27;&amp;lt;td&amp;gt;&amp;lt;&amp;#x2F;td&amp;gt;&amp;#x27;).append(&amp;#x27;&amp;lt;td&amp;gt;&amp;lt;&amp;#x2F;td&amp;gt;&amp;#x27;).appendTo(&amp;#x27;#zebra-table&amp;#x27;);
    };
});

afterEach(function () {
    $(&amp;quot;#zebra-table&amp;quot;).remove();
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;beforeEach&lt;&#x2F;code&gt; callback uses jQuery to create a table with 10 rows and 3
columns and add it to the DOM. In &lt;code&gt;afterEach&lt;&#x2F;code&gt; callback, we just remove that
table using jQuery again. Okay, now the table exists, let’s go back to the
test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;it(&amp;#x27;should apply classes zebrafy-odd and zebrafy-even to each other table lines&amp;#x27;, function () {
    var table = $(&amp;quot;#zebra-table&amp;quot;);
    table.zebrafy();
    expect(table).toBeZebrafyied();
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the second line, we call our plugin, that is not ready yet, so let’s forward
to the next line, where we used the &lt;code&gt;expect&lt;&#x2F;code&gt; function. Jasmine provides this
function, that receives an object and executes a &lt;em&gt;matcher&lt;&#x2F;em&gt; against it, there is
a lot of built-in matchers on Jasmine, but &lt;code&gt;toBeZebrafyied&lt;&#x2F;code&gt; is not a built-in
matcher. Here is where we know another Jasmine feature: the capability to write
custom matchers, but how to do this? You can call the &lt;code&gt;beforeEach&lt;&#x2F;code&gt; again, and
use the &lt;code&gt;addMatcher&lt;&#x2F;code&gt; method of Jasmine object:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;beforeEach(function () {
    this.addMatchers({
        toBeZebrafyied: function() {
            var isZebrafyied = true;

            this.actual.find(&amp;quot;tr:even&amp;quot;).each(function (index, tr) {
                isZebrafyied = $(tr).hasClass(&amp;#x27;zebrafy-odd&amp;#x27;) === false &amp;amp;&amp;amp; $(tr).hasClass(&amp;#x27;zebrafy-even&amp;#x27;);
                if (!isZebrafyied) {
                    return;
                };
            });

            this.actual.find(&amp;quot;tr:odd&amp;quot;).each(function (index, tr) {
                isZebrafyied = $(tr).hasClass(&amp;#x27;zebrafy-odd&amp;#x27;) &amp;amp;&amp;amp; $(tr).hasClass(&amp;#x27;zebrafy-even&amp;#x27;) === false;
                if (!isZebrafyied) {
                    return;
                };
            });

            return isZebrafyied;
        }
    });
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method &lt;code&gt;addMatchers&lt;&#x2F;code&gt; receives an object where each property is a matcher.
Your matcher can receive arguments if you want. The object being matched can be
accessed using &lt;code&gt;this.actual&lt;&#x2F;code&gt;, so here is what the method above does: it takes
all odd &lt;code&gt;&amp;lt;tr&amp;gt;&lt;&#x2F;code&gt; elements of the table (&lt;code&gt;this.actual&lt;&#x2F;code&gt;) and check if them have the
CSS class &lt;code&gt;zebrafy-odd&lt;&#x2F;code&gt; and don’t have the CSS class &lt;code&gt;zebrafy-even&lt;&#x2F;code&gt;, then do
the same checking with even &lt;code&gt;&amp;lt;tr&amp;gt;&lt;&#x2F;code&gt; lines.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we have wrote the test, it’s time to write the plugin. Here some
jQuery code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;(function ($) {
    $.fn.zebrafy = function () {
        this.find(&amp;quot;tr:even&amp;quot;).addClass(&amp;quot;zebrafy-even&amp;quot;);
        this.find(&amp;quot;tr:odd&amp;quot;).addClass(&amp;quot;zebrafy-odd&amp;quot;);
    };
})(jQuery);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I’m not going to explain &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;docs.jquery.com&#x2F;Plugins&#x2F;Authoring&quot;&gt;how to implement a jQuery
plugin&lt;&#x2F;a&gt; neither &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;benalman.com&#x2F;news&#x2F;2010&#x2F;11&#x2F;immediately-invoked-function-expression&#x2F;&quot;&gt;what are those
brackets on
function&lt;&#x2F;a&gt;,
this post aims to show how to use Jasmine to test jQuery plugins.&lt;&#x2F;p&gt;
&lt;p&gt;By convention, jQuery plugins are “chainable”, so let’s make sure the zebrafy
plugin is chainable using a spec:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;it(&amp;#x27;zebrafy should be chainable&amp;#x27;, function() {
    var table = $(&amp;quot;#zebra-table&amp;quot;);
    table.zebrafy().addClass(&amp;#x27;black-bg&amp;#x27;);
    expect(table.hasClass(&amp;#x27;black-bg&amp;#x27;)).toBeTruthy();
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, we used the built-in matcher &lt;code&gt;toBeTruthy&lt;&#x2F;code&gt;, which asserts that
an object or expression is &lt;code&gt;true&lt;&#x2F;code&gt;. All we need to do is return the jQuery
object in the plugin and the test will pass:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;(function ($) {
    $.fn.zebrafy = function () {
        return this.each(function (index, table) {
            $(table).find(&amp;quot;tr:even&amp;quot;).addClass(&amp;quot;zebrafy-even&amp;quot;);
            $(table).find(&amp;quot;tr:odd&amp;quot;).addClass(&amp;quot;zebrafy-odd&amp;quot;);
        });
    };
})(jQuery);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So, the plugin is tested and ready to release! :) You can check the entire code
and test with more spec in a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fsouza&#x2F;jquery-testing-jasmine&quot;&gt;GitHub
repository&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Splinter: Python tool for acceptance tests on web applications</title>
		<published>2011-05-14T00:00:00+00:00</published>
		<updated>2011-05-14T00:00:00+00:00</updated>
		<link href="https://blog.fsouza.dev/splinter-python-tool-for-acceptance/" type="text/html"/>
		<id>https://blog.fsouza.dev/splinter-python-tool-for-acceptance/</id>
		<content type="html">&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jnicklas&#x2F;capybara&quot;&gt;Capybara&lt;&#x2F;a&gt; and
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;brynary&#x2F;webrat&quot;&gt;Webrat&lt;&#x2F;a&gt; are great Ruby tools for acceptance
tests. A few months ago, we started a great tool for acceptance tests in
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;python.org&#x2F;&quot;&gt;Python&lt;&#x2F;a&gt; web applications, called
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;splinter.rtfd.org&quot;&gt;Splinter&lt;&#x2F;a&gt;. There are many acceptance test
tools on Python world: &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;seleniumhq.org&#x2F;&quot;&gt;Selenium&lt;&#x2F;a&gt;,
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;idealistdev&#x2F;alfajor&quot;&gt;Alfajor&lt;&#x2F;a&gt;,
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.getwindmill.com&#x2F;&quot;&gt;Windmill&lt;&#x2F;a&gt;,
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;wwwsearch.sourceforge.net&#x2F;mechanize&#x2F;&quot;&gt;Mechanize&lt;&#x2F;a&gt;,
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;zope.testbrowser&quot;&gt;zope.testbrowser&lt;&#x2F;a&gt;, etc.
Splinter was not created to be another acceptance tool, but an abstract layer
over other tools, its goal is provide a unique API that make acceptance testing
easier and funnier.&lt;&#x2F;p&gt;
&lt;p&gt;In this post, I will show some basic usage of Splinter for simple web
application tests. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cobrateam&#x2F;splinter&quot;&gt;Splinter&lt;&#x2F;a&gt; is a tool
useful on tests of any web application. You can even test a Java web
application using Splinter. This post example is a &amp;quot;test&amp;quot; of a Facebook
feature, just because I want to focus on how to use Splinter, not on how to
write a web application. The feature to be tested is the creation of an event
(the Splinter sprint), following all the flow: first the user will login on
Facebook, then click on &amp;quot;Events&amp;quot; menu item, then click on &amp;quot;Create an Event&amp;quot;
button, enter all event information and click on &amp;quot;Create event&amp;quot; button. So,
let’s do it…&lt;&#x2F;p&gt;
&lt;p&gt;First step is create a
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;splinter.readthedocs.io&#x2F;en&#x2F;latest&#x2F;api&#x2F;driver-and-element-api.html#module-splinter.browser&quot;&gt;Browser&lt;&#x2F;a&gt;
instance, which will provide method for interactions with browser (where the
browser is: Firefox, Chrome, etc.). The code we need for it is very simple:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;browser = Browser(&amp;quot;firefox&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Browser&lt;&#x2F;code&gt; is a class and its constructor receives the driver to be used with
that instance. Nowadays, there are three drivers for Splinter: &lt;code&gt;firefox&lt;&#x2F;code&gt;,
&lt;code&gt;chrome&lt;&#x2F;code&gt; and &lt;code&gt;zope.testbrowser&lt;&#x2F;code&gt;. We are using Firefox, and you can easily use
Chrome by simply changing the driver from &lt;code&gt;firefox&lt;&#x2F;code&gt; to &lt;code&gt;chrome&lt;&#x2F;code&gt;. It’s also very
simple to add another driver to Splinter, and I plan to cover how to do that in
another blog post here.&lt;&#x2F;p&gt;
&lt;p&gt;A new browser session is started when we got the &lt;code&gt;browser&lt;&#x2F;code&gt; object, and this is
the object used for Firefox interactions. Let&#x27;s start a new event on Facebook,
the Splinter Sprint. First of all, we need to &lt;em&gt;visit&lt;&#x2F;em&gt; the Facebook homepage.
There is a &lt;code&gt;visit&lt;&#x2F;code&gt; method on Browser class, so we can use it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;browser.visit(&amp;quot;https:&amp;#x2F;&amp;#x2F;www.facebook.com&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;visit&lt;&#x2F;code&gt; is a blocking operation: it waits for page to load, then we can
navigate, click on links, fill forms, etc. Now we have Facebook homepage opened
on browser, and you probably know that we need to login on Facebook page, but
what if we are already logged in? So, let&#x27;s create a method that login on
Facebook with provided authentication data only the user is not logged in
(imagine we are on a &lt;code&gt;Test&lt;&#x2F;code&gt;Case class):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def do_login_if_need(self, username, password):
    if self.browser.is_element_present_by_css(&amp;#x27;div.menu_login_container&amp;#x27;):
        self.browser.fill(&amp;#x27;email&amp;#x27;, username)
        self.browser.fill(&amp;#x27;pass&amp;#x27;, password)
        self.browser.find_by_css(&amp;#x27;div.menu_login_container input[type=&amp;quot;submit&amp;quot;]&amp;#x27;).first.click()
        assert self.browser.is_element_present_by_css(&amp;#x27;li#navAccount&amp;#x27;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What was made here? First of all, the method checks if there is an element
present on the page, using a CSS selector. It checks for a &lt;code&gt;div&lt;&#x2F;code&gt; that contains
the &lt;em&gt;username&lt;&#x2F;em&gt; and &lt;em&gt;password&lt;&#x2F;em&gt; fields. If that div is present, we tell the
browser object to fill those fields, then find the &lt;code&gt;submit&lt;&#x2F;code&gt; button and click on
it. The last line is an assert to guarantee that the login was successful and
the current page is the Facebook homepage (by checking the presence of
“Account” &lt;code&gt;li&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;We could also &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;splinter.rtfd.org&#x2F;en&#x2F;latest&#x2F;finding.html&quot;&gt;find elements&lt;&#x2F;a&gt;
by its texts, labels or whatever appears on screen, but remember: Facebook is
an internationalized web application, and we can’t test it using only a
specific language.&lt;&#x2F;p&gt;
&lt;p&gt;Okay, now we know how to visit a webpage, check if an element is present, fill
a form and click on a button. We&#x27;re also logged in on Facebook and can finally
go ahead create the &lt;em&gt;Splinter sprint&lt;&#x2F;em&gt; event. So, here is the event creation
flow, for a user:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;On Facebook homepage, click on “Events” link, of left menu&lt;&#x2F;li&gt;
&lt;li&gt;The “Events” page will load, so click on “Create an Event” button&lt;&#x2F;li&gt;
&lt;li&gt;The user see a page with a form to create an event&lt;&#x2F;li&gt;
&lt;li&gt;Fill the date and chose the time&lt;&#x2F;li&gt;
&lt;li&gt;Define what is the name of the event, where it will happen and write a short
description for it&lt;&#x2F;li&gt;
&lt;li&gt;Invite some guests&lt;&#x2F;li&gt;
&lt;li&gt;Upload a picture for the event&lt;&#x2F;li&gt;
&lt;li&gt;Click on “Create Event” button&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;We are going to do all these steps, except the 6th, because the Splinter Sprint
will just be a public event and we don’t need to invite anybody. There are some
boring AJAX requests on Facebook that we need to deal, so there is not only
Splinter code for those steps above. First step is click on “Events” link. All
we need to do is &lt;code&gt;find&lt;&#x2F;code&gt; the link and &lt;code&gt;click&lt;&#x2F;code&gt; on it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;browser.find_by_css(&amp;#x27;li#navItem_events a&amp;#x27;).first.click()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;find_by_css&lt;&#x2F;code&gt; method takes a CSS selector and returns an
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;splinter.rtfd.org&#x2F;en&#x2F;latest&#x2F;api&#x2F;element-list.html#splinter.element_list.ElementList&quot;&gt;ElementList&lt;&#x2F;a&gt;.
So, we get the first element of the list (even when the selector returns only
an element, the return type is still a &lt;em&gt;list&lt;&#x2F;em&gt;) and click on it. Like &lt;code&gt;visit&lt;&#x2F;code&gt;
method, &lt;code&gt;click&lt;&#x2F;code&gt; is a blocking operation: the driver will only listen for new
actions when the request is finished (the page is loaded).&lt;&#x2F;p&gt;
&lt;p&gt;We’re finally on &amp;quot;new event&amp;quot; page, and there is a form on screen waiting for data of the &lt;em&gt;Splinter Sprint&lt;&#x2F;em&gt;. Let’s fill the form. Here is the code for it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;browser.fill(&amp;#x27;event_startIntlDisplay&amp;#x27;, &amp;#x27;5&amp;#x2F;21&amp;#x2F;2011&amp;#x27;)
browser.select(&amp;#x27;start_time_min&amp;#x27;, &amp;#x27;480&amp;#x27;)
browser.fill(&amp;#x27;name&amp;#x27;, &amp;#x27;Splinter sprint&amp;#x27;)
browser.fill(&amp;#x27;location&amp;#x27;, &amp;#x27;Rio de Janeiro, Brazil&amp;#x27;)
browser.fill(&amp;#x27;desc&amp;#x27;, &amp;#x27;For more info, check out the #cobratem channel on freenode!&amp;#x27;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That is it: the event is going to happen on May 21th 2011, at 8:00 in the
morning (480 minutes). As we know, the event name is &lt;em&gt;Splinter sprint&lt;&#x2F;em&gt;, and we
are going to join some guys down here in Brazil. We filled out the form using
&lt;code&gt;fill&lt;&#x2F;code&gt; and &lt;code&gt;select&lt;&#x2F;code&gt; methods.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;fill&lt;&#x2F;code&gt; method is used to fill a &amp;quot;fillable&amp;quot; field (a textarea, an input,
etc.). It receives two strings: the first is the &lt;em&gt;name&lt;&#x2F;em&gt; of the field to fill
and the second is the &lt;em&gt;value&lt;&#x2F;em&gt; that will fill the field. &lt;code&gt;select&lt;&#x2F;code&gt; is used to
select an option in a select element (a “combo box”). It also receives two
string parameters: the first is the &lt;em&gt;name&lt;&#x2F;em&gt; of the select element, and the
second is the &lt;em&gt;value&lt;&#x2F;em&gt; of the option being selected.&lt;&#x2F;p&gt;
&lt;p&gt;Imagine you have the following select element:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;html&quot; class=&quot;language-html &quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&amp;lt;select name=&amp;quot;gender&amp;quot;&amp;gt;
    &amp;lt;option value=&amp;quot;m&amp;quot;&amp;gt;Male&amp;lt;&amp;#x2F;option&amp;gt;
    &amp;lt;option value=&amp;quot;f&amp;quot;&amp;gt;Female&amp;lt;&amp;#x2F;option&amp;gt;
&amp;lt;&amp;#x2F;select&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To select “Male”, you would call the select method this way:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;browser.select(&amp;quot;gender&amp;quot;, &amp;quot;m&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The last action before click on “Create Event” button is upload a picture for
the event. On new event page, Facebook loads the file field for picture
uploading inside an &lt;code&gt;iframe&lt;&#x2F;code&gt;, so we need to switch to this frame and interact
with the form present inside the frame. To show the frame, we need to click on
“Add Event Photo” button and then switch to it, we already know how click on a
link:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;browser.find_by_css(&amp;#x27;div.eventEditUpload a.uiButton&amp;#x27;).first.click()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we click this link, Facebook makes an asynchronous request, which means
the driver does not stay blocked waiting the end of the request, so if we try
to interact with the frame BEFORE it appears, we will get an
&lt;code&gt;ElementDoesNotExist&lt;&#x2F;code&gt; exception. Splinter provides the &lt;code&gt;is_element_present&lt;&#x2F;code&gt;
method that receives an argument called &lt;code&gt;wait_time&lt;&#x2F;code&gt;, which is the time Splinter
will wait for the element to appear on the screen. If the element does not
appear on screen, we can’t go on, so we can assume the test failed (remember we
are testing a Facebook feature):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;if not browser.is_element_present_by_css(&amp;#x27;iframe#upload_pic_frame&amp;#x27;, wait_time=10):
    fail(&amp;quot;The upload pic iframe did&amp;#x27;n&amp;#x27;t appear :(&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;is_element_present_by_css&lt;&#x2F;code&gt; method takes a CSS selector and tries to find
an element using it. It also receives a &lt;code&gt;wait_time&lt;&#x2F;code&gt; parameter that indicates a
time out for the search of the element. So, if the &lt;code&gt;iframe&lt;&#x2F;code&gt; element with
&lt;em&gt;ID=”upload_pic_frame”&lt;&#x2F;em&gt; is not present or doesn’t appear in the screen after 10
seconds, the method returns &lt;code&gt;False&lt;&#x2F;code&gt;, otherwise it returns &lt;code&gt;True&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important:&lt;&#x2F;strong&gt; &lt;code&gt;fail&lt;&#x2F;code&gt; is a pseudocode sample and doesn’t exist (if you’re
using &lt;code&gt;unittest&lt;&#x2F;code&gt; library, you can invoke &lt;code&gt;self.fail&lt;&#x2F;code&gt; in a TestCase, exactly
what I did in [complete snippet for this
example](https:&#x2F;&#x2F;github.com&#x2F;cobrateam&#x2F;splinter&#x2F;blob&#x2F;master&#x2F;samples&#x2F;test_facebook_events.py
&amp;quot;Snippet for creating a new event on Facebook using Splinter&amp;quot;), available at
Github).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Now we see the &lt;code&gt;iframe&lt;&#x2F;code&gt; element on screen and we can finally upload the
picture. Imagine we have a variable that contains the path of the picture (and
not a file object, &lt;code&gt;StringIO&lt;&#x2F;code&gt;, or something like this), and this variable name
is &lt;code&gt;picture_path&lt;&#x2F;code&gt;, this is the code we need:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;with browser.get_iframe(&amp;#x27;upload_pic_frame&amp;#x27;) as frame:
    frame.attach_file(&amp;#x27;pic&amp;#x27;, picture_path)
    time.sleep(10)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Splinter provides the &lt;code&gt;get_iframe&lt;&#x2F;code&gt; method that changes the context and returns
another objet to interact with the content of the frame. So we call the
&lt;code&gt;attach_file&lt;&#x2F;code&gt; method, who also receives two strings: the first is the &lt;em&gt;name&lt;&#x2F;em&gt; of
the input element and the second is the absolute &lt;em&gt;path&lt;&#x2F;em&gt; to the file being sent.
Facebook also uploads the picture asynchronously, but there’s no way to wait
some element to appear on screen, so I just put Python to sleep 10 seconds on
last line.&lt;&#x2F;p&gt;
&lt;p&gt;After finish all these steps, we can finally click on “Create Event” button and
asserts that Facebook created it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;browser.find_by_css(&amp;#x27;label.uiButton input[type=&amp;quot;submit&amp;quot;]&amp;#x27;).first.click()
title = browser.find_by_css(&amp;#x27;h1 span&amp;#x27;).first.text
assert title == &amp;#x27;Splinter sprint&amp;#x27;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After create an event, Facebook redirects the browser to the event page, so we
can check if it really happened by asserting the header of the page. That’s
what the code above does: in the new event page, it click on submit button, and
after the redirect, get the text of a span element and asserts that this text
equals to &lt;em&gt;“Splinter sprint”&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;That is it! This post was an overview on Splinter API. Check out the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cobrateam&#x2F;splinter&#x2F;blob&#x2F;master&#x2F;samples&#x2F;test_facebook_events.py&quot;&gt;complete
snippet&lt;&#x2F;a&gt;,
written as a test case and also check out &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cobrateam&#x2F;splinter&quot;&gt;Splinter repository at
Github&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
